local_system:
  attached_files:
    - digit_classifier.py
    - digit_extractor.py
    - sudoku_recogniser.py
    - sudoku_renderer.py
  conversation_file:
  compile_command:
  initial_file_contents:
    digit_classifier.py: |
      """
      Convolutional‐NN based digit classifier for Sudoku recognition.
      """

      import os
      import random
      import gc
      from pathlib import Path
      from typing import Callable, Generator, Tuple, Optional

      import cv2
      import numpy as np
      import keras
      from keras import callbacks, layers, models
      import torch

      # use Torch as Keras backend
      os.environ["KERAS_BACKEND"] = "torch"

      from sudoku_renderer import SudokuRenderer, generate_and_save_test_example
      from digit_extractor import GRID_SIZE, extract_cells_from_image, rectify_grid, split_into_cells
      from sudoku_recogniser import FINAL_CONFIDENCE_THRESHOLD, print_sudoku_grid

      MODEL_FILENAME = "sudoku_digit_classifier_cnn.keras"
      MODEL_INPUT_SHAPE = (28, 28, 1)
      NUM_CLASSES = 11        # digits 0–9 plus one “empty” class
      EMPTY_LABEL = 10
      TARGET_CELL_CONTENT_SIZE = 24
      TARGET_DIGIT_RATIO = 1.5

      EPOCHS = 20
      STEPS_PER_EPOCH = 150
      BATCH_SIZE = 128
      VALIDATION_STEPS = 50

      DataBatch = Tuple[np.ndarray, np.ndarray]


      def sudoku_data_generator(
          renderer: SudokuRenderer,
          batch_size: int,
          preprocess_func: Callable[[np.ndarray], Optional[np.ndarray]],
          input_size: Tuple[int, int, int],
          target_digit_ratio: float = TARGET_DIGIT_RATIO,
      ) -> Generator[DataBatch, None, None]:
          """
          Yield balanced batches of (cell_image, label) for training.
          """
          total_cells = GRID_SIZE * GRID_SIZE
          target_digits = int(batch_size * target_digit_ratio / (1 + target_digit_ratio))
          target_empty = batch_size - target_digits
          input_h, input_w = input_size[:2]

          while True:
              x_list, y_list = [], []
              n_digits = n_empty = 0
              attempts = 0
              max_attempts = batch_size * 4

              while len(x_list) < batch_size and attempts < max_attempts:
                  attempts += 1
                  allow_empty = (random.random() < 0.8)
                  img, gt_grid, corners = renderer.render_sudoku(allow_empty=allow_empty)
                  if img is None or corners is None:
                      continue

                  rectified = rectify_grid(img, corners)
                  if rectified is None:
                      continue

                  cells, _ = split_into_cells(rectified)
                  if len(cells) != total_cells:
                      continue

                  gt_flat = gt_grid.flatten()
                  indices = list(range(total_cells))
                  random.shuffle(indices)

                  for idx in indices:
                      cell = cells[idx]
                      label = EMPTY_LABEL if gt_flat[idx] == 0 else gt_flat[idx]
                      is_empty = (label == EMPTY_LABEL)

                      if is_empty and n_empty >= target_empty:
                          continue
                      if not is_empty and n_digits >= target_digits:
                          continue

                      processed = preprocess_func(cell)
                      if processed is None or processed.shape != (input_h, input_w):
                          continue

                      x_list.append(processed)
                      y_list.append(label)
                      if is_empty:
                          n_empty += 1
                      else:
                          n_digits += 1

                      if len(x_list) >= batch_size:
                          break

              if not x_list:
                  continue

              x_arr = np.array(x_list, dtype="float32")[..., np.newaxis]
              y_arr = np.array(y_list, dtype="int64")
              perm = np.random.permutation(len(y_arr))
              yield x_arr[perm], y_arr[perm]

              del x_list, y_list, x_arr, y_arr
              gc.collect()


      class EpochTestCallback(callbacks.Callback):
          """
          Evaluate the model on a fixed Sudoku example after every `frequency` epochs.
          """

          def __init__(
              self,
              test_img_path: Path,
              gt_grid: np.ndarray,
              classifier: "DigitClassifier",
              frequency: int = 1,
          ) -> None:
              super().__init__()
              self.frequency = max(1, frequency)
              self.gt_grid = gt_grid
              self.classifier = classifier

              cells, _, _ = extract_cells_from_image(test_img_path, debug=False)
              if not cells or len(cells) != GRID_SIZE * GRID_SIZE:
                  self.preprocessed = None
                  print("[Callback] Test image preparation failed—callback disabled.")
                  return

              processed = []
              for cell in cells:
                  proc = classifier._preprocess_cell_for_model(cell)
                  if proc is None:
                      proc = np.zeros(classifier._model_input_size, dtype="float32")
                  processed.append(proc)

              self.preprocessed = np.array(processed, dtype="float32")[..., np.newaxis]

          def on_epoch_end(self, epoch: int, logs=None) -> None:
              if self.preprocessed is None or (epoch + 1) % self.frequency != 0:
                  return

              preds = self.model.predict(self.preprocessed, verbose=0)
              idxs = np.argmax(preds, axis=1)
              confs = np.max(preds, axis=1)

              final = []
              for idx, conf in zip(idxs, confs):
                  digit = idx if (idx != EMPTY_LABEL and conf >= FINAL_CONFIDENCE_THRESHOLD) else 0
                  final.append(digit)

              pred_grid = np.array(final).reshape(GRID_SIZE, GRID_SIZE)
              conf_grid = confs.reshape(GRID_SIZE, GRID_SIZE)

              print(f"\n--- Epoch {epoch+1} Test Example ---")
              print("Ground truth:")
              print_sudoku_grid(self.gt_grid, threshold=1.1)
              print("Prediction:")
              print_sudoku_grid(pred_grid, conf_grid, threshold=FINAL_CONFIDENCE_THRESHOLD)

              correct = np.sum(pred_grid == self.gt_grid)
              total = GRID_SIZE * GRID_SIZE
              print(f"Accuracy: {correct}/{total} ({correct/total:.4f})")
              print("--- End ---\n")


      class DigitClassifier:
          """
          Handles loading, training, and inference of the digit classification model.
          """

          def __init__(
              self,
              model_path: Optional[str | Path] = None,
              training_required: bool = False,
          ) -> None:
              self.model_path = Path(model_path) if model_path else Path(MODEL_FILENAME)
              self.model: Optional[keras.Model] = None
              self._model_input_size = MODEL_INPUT_SHAPE[:2]

              if not training_required and self.model_path.exists():
                  try:
                      self.model = keras.models.load_model(self.model_path)
                      loaded_shape = self.model.input_shape[1:3]
                      if loaded_shape != self._model_input_size:
                          print(
                              f"[Warning] Model input shape {loaded_shape} "
                              f"!= expected {self._model_input_size}"
                          )
                      print("Model loaded.")
                  except Exception as exc:
                      print(f"[Error] Could not load model: {exc}")

          def _build_cnn_model(self) -> keras.Model:
              """13‑layer SimpleNet backbone (all 3×3 convs)."""
              cfg_filters   = [32, 32,     # block‑1
                               64, 64,     # block‑2
                               96, 96, 96, # block‑3
                               128,128,128,128,   # block‑4
                               192,192]    # block‑5 (inc. optional 1×1 later)
              pool_after_id = {1, 3, 6, 10}       # indices after which we pool

              inputs = keras.Input(shape=MODEL_INPUT_SHAPE)
              x = inputs
              for i, f in enumerate(cfg_filters):
                  # ordinary 3×3 conv
                  x = layers.Conv2D(f, 3, padding="same", use_bias=False)(x)
                  x = layers.BatchNormalization()(x)
                  x = layers.ReLU()(x)

                  # 2×2 max‑pool **after** the i‑th conv if requested
                  if i in pool_after_id:
                      x = layers.MaxPooling2D(pool_size=2)(x)

              # optional 1×1 bottleneck (kept trainable but parameter‑cheap)
              x = layers.Conv2D(256, 1, use_bias=False)(x)
              x = layers.BatchNormalization()(x)
              x = layers.ReLU()(x)

              # global spatial pooling → soft‑max output
              x = layers.GlobalAveragePooling2D()(x)
              outputs = layers.Dense(NUM_CLASSES, activation="softmax")(x)

              model = keras.Model(inputs, outputs, name="simplenet_digits")
              model.compile(
                  optimizer=keras.optimizers.Adam(1e-3),
                  loss      ="sparse_categorical_crossentropy",
                  metrics   =["accuracy"],
              )
              model.summary()         # shows ~5 M parameters → on‑par with paper
              return model

          def _preprocess_cell_for_model(self, cell: np.ndarray) -> Optional[np.ndarray]:
              """
              Binarize, crop, center, resize, and normalize a single cell image.
              Returns a 2D float32 array of shape `_model_input_size`, or None.
              """
              if cell is None or cell.size < 10:
                  return None

              gray = (
                  cv2.cvtColor(cell, cv2.COLOR_BGR2GRAY)
                  if cell.ndim == 3 else cell.copy()
              )

              blk = max(3, min(gray.shape) // 4) | 1
              try:
                  thresh = cv2.adaptiveThreshold(
                      gray, 255,
                      cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                      cv2.THRESH_BINARY_INV,
                      blk, 7
                  )
              except cv2.error:
                  return None

              coords = cv2.findNonZero(thresh)
              if coords is None:
                  return None

              x, y, w, h = cv2.boundingRect(coords)
              if w == 0 or h == 0:
                  return None

              roi = thresh[y : y+h, x : x+w]
              scale = min(
                  TARGET_CELL_CONTENT_SIZE / w,
                  TARGET_CELL_CONTENT_SIZE / h,
              )
              new_w = max(1, int(w * scale))
              new_h = max(1, int(h * scale))
              resized = cv2.resize(roi, (new_w, new_h), interpolation=cv2.INTER_AREA)

              canvas = np.zeros(self._model_input_size, dtype=np.uint8)
              top = (self._model_input_size[0] - new_h) // 2
              left = (self._model_input_size[1] - new_w) // 2
              canvas[top:top+new_h, left:left+new_w] = resized

              return canvas.astype("float32") / 255.0

          def train(
              self,
              epochs: int = EPOCHS,
              steps_per_epoch: int = STEPS_PER_EPOCH,
              batch_size: int = BATCH_SIZE,
              validation_steps: int = VALIDATION_STEPS,
          ) -> None:
              """Train the model using synthetic Sudoku data."""
              print(
                  f"\nTraining parameters: "
                  f"epochs={epochs}, steps_per_epoch={steps_per_epoch}, "
                  f"batch_size={batch_size}, validation_steps={validation_steps}"
              )

              try:
                  test_img, test_gt = generate_and_save_test_example()
                  epoch_test_cb = EpochTestCallback(test_img, test_gt, self)
              except Exception as exc:
                  print(f"[Warning] Could not set up epoch test callback: {exc}")
                  epoch_test_cb = None

              train_gen = sudoku_data_generator(
                  SudokuRenderer(),
                  batch_size,
                  self._preprocess_cell_for_model,
                  MODEL_INPUT_SHAPE,
              )
              val_gen = sudoku_data_generator(
                  SudokuRenderer(),
                  batch_size,
                  self._preprocess_cell_for_model,
                  MODEL_INPUT_SHAPE,
              )

              if self.model is None:
                  self.model = self._build_cnn_model()

              cbs = [
                  callbacks.EarlyStopping(
                      monitor="val_loss", patience=5,
                      restore_best_weights=True, verbose=1
                  ),
                  callbacks.ModelCheckpoint(
                      filepath=self.model_path,
                      monitor="val_loss", save_best_only=True, verbose=1
                  ),
                  callbacks.ReduceLROnPlateau(
                      monitor="val_loss", factor=0.2,
                      patience=3, min_lr=1e-6, verbose=1
                  ),
              ]
              if epoch_test_cb and epoch_test_cb.preprocessed is not None:
                  cbs.append(epoch_test_cb)

              self.model.fit(
                  train_gen,
                  epochs=epochs,
                  steps_per_epoch=steps_per_epoch,
                  validation_data=val_gen,
                  validation_steps=validation_steps,
                  callbacks=cbs,
                  verbose=1,
              )

              print("\nFinal evaluation:")
              loss, acc = self.model.evaluate(
                  sudoku_data_generator(
                      SudokuRenderer(),
                      batch_size,
                      self._preprocess_cell_for_model,
                      MODEL_INPUT_SHAPE,
                  ),
                  steps=validation_steps,
                  verbose=1,
              )
              print(f"Validation loss={loss:.4f}, accuracy={acc:.4f}")

              self.model.save(self.model_path)
              del train_gen, val_gen
              gc.collect()

          @torch.no_grad()
          def recognise(
              self,
              cell: np.ndarray,
              confidence_threshold: float = 0.7,
          ) -> Tuple[int, float]:
              """
              Predict the digit in a single cell.
              Returns (digit, confidence). digit=0 indicates empty/uncertain.
              """
              if self.model is None:
                  return 0, 0.0

              proc = self._preprocess_cell_for_model(cell)
              if proc is None:
                  return 0, 0.0

              x = proc[np.newaxis, ..., np.newaxis]
              x_tensor = torch.from_numpy(x).float()
              probs = self.model(x_tensor, training=False)[0]
              if isinstance(probs, torch.Tensor):
                  probs = probs.cpu().numpy()

              idx = int(np.argmax(probs))
              conf = float(probs[idx])
              if idx == EMPTY_LABEL or conf < confidence_threshold:
                  return 0, conf
              return idx, conf


      if __name__ == "__main__":
          FORCE_TRAIN = False
          if FORCE_TRAIN and Path(MODEL_FILENAME).exists():
              Path(MODEL_FILENAME).unlink()

          classifier = DigitClassifier(training_required=FORCE_TRAIN)
          if classifier.model is None:
              classifier.train()

          if classifier.model:
              print("\nQuick dummy test:")
              dummy = np.zeros((50, 50), dtype=np.uint8)
              cv2.line(dummy, (25, 10), (25, 40), 255, 3)
              d, c = classifier.recognise(dummy, confidence_threshold=0.5)
              print(f"Pred (vertical line) -> {d}, conf={c:.3f}")

              empty = np.zeros((50, 50), dtype=np.uint8)
              d, c = classifier.recognise(empty, confidence_threshold=0.5)
              print(f"Pred (blank)         -> {d}, conf={c:.3f}")
    digit_extractor.py: |
      """
      Find and extract Sudoku grid cells from an image.
      """

      import os
      from pathlib import Path
      from typing import List, Tuple, Optional

      import cv2
      import numpy as np

      GRID_SIZE = 9
      DEFAULT_RECTIFIED_SIZE = 450


      def _order_points(pts: np.ndarray) -> np.ndarray:
          """Order four points as top-left, top-right, bottom-right, bottom-left."""
          pts = pts.reshape(4, 2).astype("float32")
          rect = np.zeros((4, 2), dtype="float32")
          s = pts.sum(axis=1)
          rect[0] = pts[np.argmin(s)]
          rect[2] = pts[np.argmax(s)]
          diff = pts[:, 1] - pts[:, 0]
          rect[1] = pts[np.argmin(diff)]
          rect[3] = pts[np.argmax(diff)]
          return rect


      def find_sudoku_grid_contour(
          img: np.ndarray,
          debug_dir: Optional[Path] = None
      ) -> np.ndarray:
          """
          Find the largest 4-point contour approximating the Sudoku grid boundary.
          """
          gray = (
              cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
              if img.ndim == 3 else img.copy()
          )

          if debug_dir:
              debug_dir.mkdir(parents=True, exist_ok=True)

          blur = cv2.GaussianBlur(gray, (7, 7), 0)
          thresh = cv2.adaptiveThreshold(
              blur, 255,
              cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
              cv2.THRESH_BINARY_INV,
              15, 4
          )
          closed = cv2.morphologyEx(
              thresh,
              cv2.MORPH_CLOSE,
              cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3)),
              iterations=2
          )

          contours, _ = cv2.findContours(
              closed, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE
          )
          contours = sorted(contours, key=cv2.contourArea, reverse=True)
          min_area = gray.size * 0.1

          for cnt in contours:
              if cv2.contourArea(cnt) < min_area:
                  break
              peri = cv2.arcLength(cnt, True)
              approx = cv2.approxPolyDP(cnt, 0.02 * peri, True)
              if len(approx) == 4 and cv2.isContourConvex(approx):
                  x, y, w, h = cv2.boundingRect(approx)
                  aspect = w / float(h)
                  if 0.8 < aspect < 1.2:
                      return approx.reshape(4, 2).astype("float32")

          raise ValueError("Sudoku grid contour not found.")


      def rectify_grid(
          img: np.ndarray,
          contour: np.ndarray,
          size: int = DEFAULT_RECTIFIED_SIZE
      ) -> Optional[np.ndarray]:
          """Perspective-correct the Sudoku grid to a square of given size."""
          try:
              src = _order_points(contour)
              dst = np.array([
                  [0, 0],
                  [size - 1, 0],
                  [size - 1, size - 1],
                  [0, size - 1],
              ], dtype="float32")
              mat = cv2.getPerspectiveTransform(src, dst)
              return cv2.warpPerspective(img, mat, (size, size))
          except cv2.error:
              return None


      def split_into_cells(
          rectified: np.ndarray
      ) -> Tuple[List[np.ndarray], np.ndarray]:
          """
          Split the rectified grid into GRID_SIZE × GRID_SIZE cell images.
          Returns (cells, rectified_image).
          """
          h, w = rectified.shape[:2]
          if h != w:
              size = max(h, w)
              rectified = cv2.resize(rectified, (size, size))
              h = w = size

          cell_sz = h // GRID_SIZE
          margin = int(cell_sz * 0.04)
          cells: List[np.ndarray] = []

          for row in range(GRID_SIZE):
              for col in range(GRID_SIZE):
                  y0 = row * cell_sz + margin
                  x0 = col * cell_sz + margin
                  y1 = (row + 1) * cell_sz - margin
                  x1 = (col + 1) * cell_sz - margin
                  if y0 >= y1 or x0 >= x1:
                      cell = np.zeros((cell_sz, cell_sz), rectified.dtype)
                  else:
                      cell = rectified[y0:y1, x0:x1]
                  cells.append(cell)

          return cells, rectified


      def extract_cells_from_image(
          img_or_path,
          size: int = DEFAULT_RECTIFIED_SIZE,
          debug: bool = False
      ) -> Tuple[Optional[List[np.ndarray]], Optional[np.ndarray], Optional[np.ndarray]]:
          """
          High-level function: read image, find grid, rectify, and split into cells.
          Returns (cells, rectified_image, contour) or (None, None, None) on failure.
          """
          if isinstance(img_or_path, (str, Path)):
              img = cv2.imread(str(img_or_path))
              if img is None:
                  return None, None, None
          elif isinstance(img_or_path, np.ndarray):
              img = img_or_path.copy()
          else:
              return None, None, None

          try:
              debug_dir = Path(f"debug_{os.getpid()}") if debug else None
              contour = find_sudoku_grid_contour(img, debug_dir)
              rectified = rectify_grid(img, contour, size=size)
              if rectified is None:
                  return None, None, None
              cells, rectified = split_into_cells(rectified)
              return cells, rectified, contour
          except Exception as exc:
              print(f"[Extractor] {exc}")
              return None, None, None
    sudoku_recogniser.py: |
      """
      Command-line utility to detect a Sudoku grid in an image and recognise its digits.
      """

      from __future__ import annotations

      import sys
      import time
      from pathlib import Path
      from typing import Tuple, Optional

      import cv2
      import numpy as np

      import digit_classifier
      from digit_extractor import GRID_SIZE, extract_cells_from_image

      FINAL_CONFIDENCE_THRESHOLD = 0.80


      def print_sudoku_grid(
          grid: np.ndarray,
          conf: Optional[np.ndarray] = None,
          threshold: float = FINAL_CONFIDENCE_THRESHOLD
      ) -> None:
          """Nicely print a 9×9 Sudoku grid, marking low‑confidence digits as '?'. """
          grid = np.asarray(grid)
          if grid.shape != (GRID_SIZE, GRID_SIZE):
              print("[print_sudoku_grid] invalid shape")
              return

          for r in range(GRID_SIZE):
              if r > 0 and r % 3 == 0:
                  print("|-----+-------+-----|")

              tokens = []
              for c in range(GRID_SIZE):
                  d = grid[r, c]
                  if d == 0:
                      tok = "."
                  else:
                      tok = str(d)
                      if conf is not None and conf[r, c] < threshold:
                          tok = "?"
                  tokens.append(tok)
                  if (c + 1) % 3 == 0 and c < GRID_SIZE - 1:
                      tokens.append("|")
              print(" ".join(tokens))
          print()


      def display_results_on_image(
          rectified: Optional[np.ndarray],
          grid: np.ndarray
      ) -> Optional[np.ndarray]:
          """
          Draw recognised digits onto the rectified grid image and return it.
          """
          if rectified is None:
              return None

          img = (
              cv2.cvtColor(rectified, cv2.COLOR_GRAY2BGR)
              if rectified.ndim == 2 else rectified.copy()
          )
          h, w = img.shape[:2]
          cell_h, cell_w = h // GRID_SIZE, w // GRID_SIZE

          for r in range(GRID_SIZE):
              for c in range(GRID_SIZE):
                  d = grid[r, c]
                  if d == 0:
                      continue
                  text = str(d)
                  (tw, th), _ = cv2.getTextSize(
                      text, cv2.FONT_HERSHEY_SIMPLEX, 1, 2
                  )
                  x = c * cell_w + (cell_w - tw) // 2
                  y = r * cell_h + (cell_h + th) // 2
                  cv2.putText(
                      img, text, (x, y),
                      cv2.FONT_HERSHEY_SIMPLEX,
                      1, (0, 255, 0), 2, cv2.LINE_AA
                  )
          return img


      def recognise_sudoku(
          img_path: Path,
          classifier: digit_classifier.DigitClassifier
      ) -> Tuple[np.ndarray, np.ndarray, Optional[np.ndarray]]:
          """
          Extract cells and run the classifier on each one.
          Returns (predicted_grid, confidence_grid, rectified_image).
          """
          print(f"Processing {img_path} ...")
          start = time.time()
          cells, rectified, _ = extract_cells_from_image(img_path)
          if cells is None or rectified is None:
              raise RuntimeError("Extraction failed.")

          pred = np.zeros((GRID_SIZE, GRID_SIZE), int)
          conf = np.zeros_like(pred, float)

          for i, cell in enumerate(cells):
              r, c = divmod(i, GRID_SIZE)
              d, cf = classifier.recognise(cell, confidence_threshold=0.1)
              conf[r, c] = cf
              if d != 0 and cf >= FINAL_CONFIDENCE_THRESHOLD:
                  pred[r, c] = d

          elapsed = time.time() - start
          print(f"Done in {elapsed:.2f}s")
          return pred, conf, rectified


      def main() -> None:
          if len(sys.argv) < 2:
              print("Usage: sudoku_recogniser.py <image_path>")
              sys.exit(0)

          img_path = Path(sys.argv[1])
          if not img_path.exists():
              print(f"Image not found: {img_path}")
              sys.exit(1)

          classifier = digit_classifier.DigitClassifier(model_path=digit_classifier.MODEL_FILENAME)
          if classifier.model is None:
              print("Model missing—training required.")
              classifier.train()

          grid, conf, rectified = recognise_sudoku(img_path, classifier)
          print_sudoku_grid(grid, conf)

          result_img = display_results_on_image(rectified, grid)
          if result_img is not None:
              cv2.imshow("Sudoku Recognition", result_img)
              cv2.waitKey(0)
              cv2.destroyAllWindows()


      if __name__ == "__main__":
          main()
    sudoku_renderer.py: |
      """
      Synthetic Sudoku image generator for on‑the‑fly training data.
      """

      import random
      from pathlib import Path
      from typing import Tuple, Optional

      import cv2
      import numpy as np
      import keras

      GRID_SIZE = 9
      BASE_IMAGE_SIZE = 1000
      CELL_SIZE = BASE_IMAGE_SIZE // GRID_SIZE


      def _order_points(pts: np.ndarray) -> np.ndarray:
          """Order four points as TL, TR, BR, BL."""
          pts = pts.reshape(4, 2).astype("float32")
          rect = np.zeros((4, 2), dtype="float32")
          s = pts.sum(axis=1)
          rect[0] = pts[np.argmin(s)]
          rect[2] = pts[np.argmax(s)]
          diff = pts[:, 1] - pts[:, 0]
          rect[1] = pts[np.argmin(diff)]
          rect[3] = pts[np.argmax(diff)]
          return rect


      def _load_mnist_digits() -> dict[int, list[np.ndarray]]:
          """
          Download MNIST once and bucket images by label for rendering.
          """
          (x_train, y_train), (x_test, y_test) = keras.datasets.mnist.load_data()
          images = np.concatenate([x_train, x_test])
          labels = np.concatenate([y_train, y_test])

          buckets: dict[int, list[np.ndarray]] = {i: [] for i in range(10)}
          for img, lbl in zip(images, labels):
              inv = cv2.bitwise_not(img)
              padded = cv2.copyMakeBorder(
                  inv, 4, 4, 4, 4,
                  cv2.BORDER_CONSTANT, value=255
              )
              buckets[int(lbl)].append(padded)
          return buckets


      class SudokuRenderer:
          """
          Render a random (or specified) Sudoku grid to a synthetic image.
          """

          def __init__(self) -> None:
              self.mnist_buckets: Optional[dict[int, list[np.ndarray]]] = None

          def _digit_source(self, digit: int) -> Tuple[Optional[np.ndarray], str]:
              if self.mnist_buckets is None:
                  self.mnist_buckets = _load_mnist_digits()

              sources = []
              if self.mnist_buckets[digit]:
                  sources.append("mnist")
              sources.append("font")
              choice = random.choice(sources)

              if choice == "mnist":
                  img = random.choice(self.mnist_buckets[digit])
                  if img.ndim == 2:
                      img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
                  return img, "mnist"
              return None, "font"

          def render_sudoku(
              self,
              grid_spec: Optional[list[list[int | None]]] = None,
              *,
              allow_empty: bool = True
          ) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
              """
              Generate a synthetic Sudoku image.
              Returns (image, ground_truth_grid, warped_corners).
              """
              if grid_spec is None:
                  gt = np.zeros((GRID_SIZE, GRID_SIZE), int)
                  for r in range(GRID_SIZE):
                      for c in range(GRID_SIZE):
                          if allow_empty and random.random() < 0.4:
                              continue
                          gt[r, c] = random.randint(1, 9)
              else:
                  gt = np.array([[d or 0 for d in row] for row in grid_spec], int)

              bg = tuple(random.randint(200, 240) for _ in range(3))
              img = np.full((BASE_IMAGE_SIZE, BASE_IMAGE_SIZE, 3), bg, np.uint8)

              # draw grid lines
              for i in range(GRID_SIZE + 1):
                  major = (i % 3 == 0)
                  thickness = random.randint(3 if major else 1, 5 if major else 3)
                  cv2.line(img, (0, i*CELL_SIZE), (BASE_IMAGE_SIZE, i*CELL_SIZE), (0, 0, 0), thickness)
                  cv2.line(img, (i*CELL_SIZE, 0), (i*CELL_SIZE, BASE_IMAGE_SIZE), (0, 0, 0), thickness)

              # draw digits
              for r in range(GRID_SIZE):
                  for c in range(GRID_SIZE):
                      d = gt[r, c]
                      if d == 0:
                          continue

                      src_img, src_type = self._digit_source(d)
                      scale = random.uniform(0.5, 0.8)
                      tgt = int(CELL_SIZE * scale)
                      center_x = c*CELL_SIZE + CELL_SIZE//2
                      center_y = r*CELL_SIZE + CELL_SIZE//2
                      dx = int(random.uniform(-0.1, 0.1)*CELL_SIZE)
                      dy = int(random.uniform(-0.1, 0.1)*CELL_SIZE)
                      cx, cy = center_x + dx, center_y + dy

                      if src_type == "mnist":
                          digit = cv2.resize(src_img, (tgt, tgt))
                          angle = random.uniform(-10, 10)
                          M = cv2.getRotationMatrix2D((tgt/2, tgt/2), angle, 1)
                          digit = cv2.warpAffine(
                              digit, M, (tgt, tgt),
                              borderMode=cv2.BORDER_CONSTANT, borderValue=(255,255,255)
                          )
                          mask = cv2.cvtColor(digit, cv2.COLOR_BGR2GRAY)
                          _, mask = cv2.threshold(mask, 250, 255, cv2.THRESH_BINARY_INV)

                          x0 = max(0, cx - tgt//2)
                          y0 = max(0, cy - tgt//2)
                          roi = img[y0:y0+tgt, x0:x0+tgt]
                          m_inv = cv2.bitwise_not(mask[:roi.shape[0], :roi.shape[1]])
                          bg_region = cv2.bitwise_and(roi, roi, mask=m_inv)
                          fg_region = cv2.bitwise_and(digit, digit, mask=mask[:roi.shape[0], :roi.shape[1]])
                          img[y0:y0+roi.shape[0], x0:x0+roi.shape[1]] = cv2.add(bg_region, fg_region)
                      else:
                          font = cv2.FONT_HERSHEY_SIMPLEX
                          thickness = random.randint(1, 3)
                          font_scale = cv2.getFontScaleFromHeight(font, tgt, thickness) * 0.8
                          text = str(d)
                          tw, th = cv2.getTextSize(text, font, font_scale, thickness)[0]
                          x = cx - tw//2
                          y = cy + th//2
                          cv2.putText(img, text, (x, y),
                                      font, font_scale, (0, 0, 0), thickness, cv2.LINE_AA)

              # add noise
              noise = np.random.normal(0, random.uniform(5,20), img.shape).astype(np.float32)
              noisy = np.clip(img.astype(np.float32) + noise, 0, 255).astype(np.uint8)

              # random perspective warp
              h, w = noisy.shape[:2]
              orig = np.array([[0,0],[w-1,0],[w-1,h-1],[0,h-1]], dtype="float32")
              shift = random.uniform(0.05, 0.2)
              max_dx, max_dy = w*shift, h*shift
              dst = np.array([
                  [random.uniform(0, max_dx), random.uniform(0, max_dy)],
                  [w-1-random.uniform(0, max_dx), random.uniform(0, max_dy)],
                  [w-1-random.uniform(-max_dx*0.2, max_dx), h-1-random.uniform(0, max_dy)],
                  [random.uniform(-max_dx*0.2, max_dx), h-1-random.uniform(0, max_dy)],
              ], dtype="float32")
              M = cv2.getPerspectiveTransform(orig, dst)
              out_w = int(dst[:,0].max()) + 1
              out_h = int(dst[:,1].max()) + 1
              warped = cv2.warpPerspective(
                  noisy, M, (out_w, out_h), borderMode=cv2.BORDER_REPLICATE
              )

              return warped, gt, dst


      def generate_and_save_test_example(
          prefix: str = "epoch_test_sudoku",
          force: bool = False
      ) -> Tuple[str, np.ndarray]:
          """
          Generate or load a fixed Sudoku test example for epoch callbacks.
          Returns (image_path, ground_truth_grid).
          """
          img_path = Path(f"{prefix}.png")
          gt_path = Path(f"{prefix}_gt.npy")

          if not force and img_path.exists() and gt_path.exists():
              return str(img_path), np.load(gt_path)

          renderer = SudokuRenderer()
          grid_spec = [
              [None, None, 3,    None, None, 6,    None, 8,    None],
              [8,    None, 1,    None, 3,    None, 5,    None, 4   ],
              [None, 4,    None, 8,    None, 7,    None, 1,    None],
              [1,    None, None, 4,    None, 5,    None, None, 9   ],
              [None, 7,    None, None, 2,    None, None, 4,    None],
              [5,    None, None, 7,    None, 1,    None, None, 3   ],
              [None, 8,    None, 5,    None, 3,    None, 9,    None],
              [7,    None, 4,    None, 9,    None, 1,    None, 8   ],
              [None, 1,    None, 6,    None, None, 4,    None, None],
          ]
          img, gt, _ = renderer.render_sudoku(grid_spec=grid_spec)
          cv2.imwrite(str(img_path), img)
          np.save(gt_path, gt)
          return str(img_path), gt
  prev_file_contents:
    digit_classifier.py: |
      """
      Convolutional‐NN based digit classifier for Sudoku recognition.
      """

      import os
      import random
      import gc
      from pathlib import Path
      from typing import Callable, Generator, Tuple, Optional

      import cv2
      import numpy as np
      import keras
      from keras import callbacks, layers, models
      import torch

      # use Torch as Keras backend
      os.environ["KERAS_BACKEND"] = "torch"

      from sudoku_renderer import SudokuRenderer, generate_and_save_test_example
      from digit_extractor import GRID_SIZE, extract_cells_from_image, rectify_grid, split_into_cells
      from sudoku_recogniser import FINAL_CONFIDENCE_THRESHOLD, print_sudoku_grid

      MODEL_FILENAME = "sudoku_digit_classifier_cnn.keras"
      MODEL_INPUT_SHAPE = (28, 28, 1)
      NUM_CLASSES = 11        # digits 0–9 plus one “empty” class
      EMPTY_LABEL = 10
      TARGET_CELL_CONTENT_SIZE = 24
      TARGET_DIGIT_RATIO = 1.5

      EPOCHS = 20
      STEPS_PER_EPOCH = 150
      BATCH_SIZE = 128
      VALIDATION_STEPS = 50

      DataBatch = Tuple[np.ndarray, np.ndarray]


      def sudoku_data_generator(
          renderer: SudokuRenderer,
          batch_size: int,
          preprocess_func: Callable[[np.ndarray], Optional[np.ndarray]],
          input_size: Tuple[int, int, int],
          target_digit_ratio: float = TARGET_DIGIT_RATIO,
      ) -> Generator[DataBatch, None, None]:
          """
          Yield balanced batches of (cell_image, label) for training.
          """
          total_cells = GRID_SIZE * GRID_SIZE
          target_digits = int(batch_size * target_digit_ratio / (1 + target_digit_ratio))
          target_empty = batch_size - target_digits
          input_h, input_w = input_size[:2]

          while True:
              x_list, y_list = [], []
              n_digits = n_empty = 0
              attempts = 0
              max_attempts = batch_size * 4

              while len(x_list) < batch_size and attempts < max_attempts:
                  attempts += 1
                  allow_empty = (random.random() < 0.8)
                  img, gt_grid, corners = renderer.render_sudoku(allow_empty=allow_empty)
                  if img is None or corners is None:
                      continue

                  rectified = rectify_grid(img, corners)
                  if rectified is None:
                      continue

                  cells, _ = split_into_cells(rectified)
                  if len(cells) != total_cells:
                      continue

                  gt_flat = gt_grid.flatten()
                  indices = list(range(total_cells))
                  random.shuffle(indices)

                  for idx in indices:
                      cell = cells[idx]
                      label = EMPTY_LABEL if gt_flat[idx] == 0 else gt_flat[idx]
                      is_empty = (label == EMPTY_LABEL)

                      if is_empty and n_empty >= target_empty:
                          continue
                      if not is_empty and n_digits >= target_digits:
                          continue

                      processed = preprocess_func(cell)
                      if processed is None or processed.shape != (input_h, input_w):
                          continue

                      x_list.append(processed)
                      y_list.append(label)
                      if is_empty:
                          n_empty += 1
                      else:
                          n_digits += 1

                      if len(x_list) >= batch_size:
                          break

              if not x_list:
                  continue

              x_arr = np.array(x_list, dtype="float32")[..., np.newaxis]
              y_arr = np.array(y_list, dtype="int64")
              perm = np.random.permutation(len(y_arr))
              yield x_arr[perm], y_arr[perm]

              del x_list, y_list, x_arr, y_arr
              gc.collect()


      class EpochTestCallback(callbacks.Callback):
          """
          Evaluate the model on a fixed Sudoku example after every `frequency` epochs.
          """

          def __init__(
              self,
              test_img_path: Path,
              gt_grid: np.ndarray,
              classifier: "DigitClassifier",
              frequency: int = 1,
          ) -> None:
              super().__init__()
              self.frequency = max(1, frequency)
              self.gt_grid = gt_grid
              self.classifier = classifier

              cells, _, _ = extract_cells_from_image(test_img_path, debug=False)
              if not cells or len(cells) != GRID_SIZE * GRID_SIZE:
                  self.preprocessed = None
                  print("[Callback] Test image preparation failed—callback disabled.")
                  return

              processed = []
              for cell in cells:
                  proc = classifier._preprocess_cell_for_model(cell)
                  if proc is None:
                      proc = np.zeros(classifier._model_input_size, dtype="float32")
                  processed.append(proc)

              self.preprocessed = np.array(processed, dtype="float32")[..., np.newaxis]

          def on_epoch_end(self, epoch: int, logs=None) -> None:
              if self.preprocessed is None or (epoch + 1) % self.frequency != 0:
                  return

              preds = self.model.predict(self.preprocessed, verbose=0)
              idxs = np.argmax(preds, axis=1)
              confs = np.max(preds, axis=1)

              final = []
              for idx, conf in zip(idxs, confs):
                  digit = idx if (idx != EMPTY_LABEL and conf >= FINAL_CONFIDENCE_THRESHOLD) else 0
                  final.append(digit)

              pred_grid = np.array(final).reshape(GRID_SIZE, GRID_SIZE)
              conf_grid = confs.reshape(GRID_SIZE, GRID_SIZE)

              print(f"\n--- Epoch {epoch+1} Test Example ---")
              print("Ground truth:")
              print_sudoku_grid(self.gt_grid, threshold=1.1)
              print("Prediction:")
              print_sudoku_grid(pred_grid, conf_grid, threshold=FINAL_CONFIDENCE_THRESHOLD)

              correct = np.sum(pred_grid == self.gt_grid)
              total = GRID_SIZE * GRID_SIZE
              print(f"Accuracy: {correct}/{total} ({correct/total:.4f})")
              print("--- End ---\n")


      class DigitClassifier:
          """
          Handles loading, training, and inference of the digit classification model.
          """

          def __init__(
              self,
              model_path: Optional[str | Path] = None,
              training_required: bool = False,
          ) -> None:
              self.model_path = Path(model_path) if model_path else Path(MODEL_FILENAME)
              self.model: Optional[keras.Model] = None
              self._model_input_size = MODEL_INPUT_SHAPE[:2]

              if not training_required and self.model_path.exists():
                  try:
                      self.model = keras.models.load_model(self.model_path)
                      loaded_shape = self.model.input_shape[1:3]
                      if loaded_shape != self._model_input_size:
                          print(
                              f"[Warning] Model input shape {loaded_shape} "
                              f"!= expected {self._model_input_size}"
                          )
                      print("Model loaded.")
                  except Exception as exc:
                      print(f"[Error] Could not load model: {exc}")

          def _build_cnn_model(self) -> keras.Model:
              """13‑layer SimpleNet backbone (all 3×3 convs)."""
              cfg_filters   = [32, 32,     # block‑1
                               64, 64,     # block‑2
                               96, 96, 96, # block‑3
                               128,128,128,128,   # block‑4
                               192,192]    # block‑5 (inc. optional 1×1 later)
              pool_after_id = {1, 3, 6, 10}       # indices after which we pool

              inputs = keras.Input(shape=MODEL_INPUT_SHAPE)
              x = inputs
              for i, f in enumerate(cfg_filters):
                  # ordinary 3×3 conv
                  x = layers.Conv2D(f, 3, padding="same", use_bias=False)(x)
                  x = layers.BatchNormalization()(x)
                  x = layers.ReLU()(x)

                  # 2×2 max‑pool **after** the i‑th conv if requested
                  if i in pool_after_id:
                      x = layers.MaxPooling2D(pool_size=2)(x)

              # optional 1×1 bottleneck (kept trainable but parameter‑cheap)
              x = layers.Conv2D(256, 1, use_bias=False)(x)
              x = layers.BatchNormalization()(x)
              x = layers.ReLU()(x)

              # global spatial pooling → soft‑max output
              x = layers.GlobalAveragePooling2D()(x)
              outputs = layers.Dense(NUM_CLASSES, activation="softmax")(x)

              model = keras.Model(inputs, outputs, name="simplenet_digits")
              model.compile(
                  optimizer=keras.optimizers.Adam(1e-3),
                  loss      ="sparse_categorical_crossentropy",
                  metrics   =["accuracy"],
              )
              model.summary()         # shows ~5 M parameters → on‑par with paper
              return model

          def _preprocess_cell_for_model(self, cell: np.ndarray) -> Optional[np.ndarray]:
              """
              Binarize, crop, center, resize, and normalize a single cell image.
              Returns a 2D float32 array of shape `_model_input_size`, or None.
              """
              if cell is None or cell.size < 10:
                  return None

              gray = (
                  cv2.cvtColor(cell, cv2.COLOR_BGR2GRAY)
                  if cell.ndim == 3 else cell.copy()
              )

              blk = max(3, min(gray.shape) // 4) | 1
              try:
                  thresh = cv2.adaptiveThreshold(
                      gray, 255,
                      cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                      cv2.THRESH_BINARY_INV,
                      blk, 7
                  )
              except cv2.error:
                  return None

              coords = cv2.findNonZero(thresh)
              if coords is None:
                  return None

              x, y, w, h = cv2.boundingRect(coords)
              if w == 0 or h == 0:
                  return None

              roi = thresh[y : y+h, x : x+w]
              scale = min(
                  TARGET_CELL_CONTENT_SIZE / w,
                  TARGET_CELL_CONTENT_SIZE / h,
              )
              new_w = max(1, int(w * scale))
              new_h = max(1, int(h * scale))
              resized = cv2.resize(roi, (new_w, new_h), interpolation=cv2.INTER_AREA)

              canvas = np.zeros(self._model_input_size, dtype=np.uint8)
              top = (self._model_input_size[0] - new_h) // 2
              left = (self._model_input_size[1] - new_w) // 2
              canvas[top:top+new_h, left:left+new_w] = resized

              return canvas.astype("float32") / 255.0

          def train(
              self,
              epochs: int = EPOCHS,
              steps_per_epoch: int = STEPS_PER_EPOCH,
              batch_size: int = BATCH_SIZE,
              validation_steps: int = VALIDATION_STEPS,
          ) -> None:
              """Train the model using synthetic Sudoku data."""
              print(
                  f"\nTraining parameters: "
                  f"epochs={epochs}, steps_per_epoch={steps_per_epoch}, "
                  f"batch_size={batch_size}, validation_steps={validation_steps}"
              )

              try:
                  test_img, test_gt = generate_and_save_test_example()
                  epoch_test_cb = EpochTestCallback(test_img, test_gt, self)
              except Exception as exc:
                  print(f"[Warning] Could not set up epoch test callback: {exc}")
                  epoch_test_cb = None

              train_gen = sudoku_data_generator(
                  SudokuRenderer(),
                  batch_size,
                  self._preprocess_cell_for_model,
                  MODEL_INPUT_SHAPE,
              )
              val_gen = sudoku_data_generator(
                  SudokuRenderer(),
                  batch_size,
                  self._preprocess_cell_for_model,
                  MODEL_INPUT_SHAPE,
              )

              if self.model is None:
                  self.model = self._build_cnn_model()

              cbs = [
                  callbacks.EarlyStopping(
                      monitor="val_loss", patience=5,
                      restore_best_weights=True, verbose=1
                  ),
                  callbacks.ModelCheckpoint(
                      filepath=self.model_path,
                      monitor="val_loss", save_best_only=True, verbose=1
                  ),
                  callbacks.ReduceLROnPlateau(
                      monitor="val_loss", factor=0.2,
                      patience=3, min_lr=1e-6, verbose=1
                  ),
              ]
              if epoch_test_cb and epoch_test_cb.preprocessed is not None:
                  cbs.append(epoch_test_cb)

              self.model.fit(
                  train_gen,
                  epochs=epochs,
                  steps_per_epoch=steps_per_epoch,
                  validation_data=val_gen,
                  validation_steps=validation_steps,
                  callbacks=cbs,
                  verbose=1,
              )

              print("\nFinal evaluation:")
              loss, acc = self.model.evaluate(
                  sudoku_data_generator(
                      SudokuRenderer(),
                      batch_size,
                      self._preprocess_cell_for_model,
                      MODEL_INPUT_SHAPE,
                  ),
                  steps=validation_steps,
                  verbose=1,
              )
              print(f"Validation loss={loss:.4f}, accuracy={acc:.4f}")

              self.model.save(self.model_path)
              del train_gen, val_gen
              gc.collect()

          @torch.no_grad()
          def recognise(
              self,
              cell: np.ndarray,
              confidence_threshold: float = 0.7,
          ) -> Tuple[int, float]:
              """
              Predict the digit in a single cell.
              Returns (digit, confidence). digit=0 indicates empty/uncertain.
              """
              if self.model is None:
                  return 0, 0.0

              proc = self._preprocess_cell_for_model(cell)
              if proc is None:
                  return 0, 0.0

              x = proc[np.newaxis, ..., np.newaxis]
              x_tensor = torch.from_numpy(x).float()
              probs = self.model(x_tensor, training=False)[0]
              if isinstance(probs, torch.Tensor):
                  probs = probs.cpu().numpy()

              idx = int(np.argmax(probs))
              conf = float(probs[idx])
              if idx == EMPTY_LABEL or conf < confidence_threshold:
                  return 0, conf
              return idx, conf


      if __name__ == "__main__":
          FORCE_TRAIN = False
          if FORCE_TRAIN and Path(MODEL_FILENAME).exists():
              Path(MODEL_FILENAME).unlink()

          classifier = DigitClassifier(training_required=FORCE_TRAIN)
          if classifier.model is None:
              classifier.train()

          if classifier.model:
              print("\nQuick dummy test:")
              dummy = np.zeros((50, 50), dtype=np.uint8)
              cv2.line(dummy, (25, 10), (25, 40), 255, 3)
              d, c = classifier.recognise(dummy, confidence_threshold=0.5)
              print(f"Pred (vertical line) -> {d}, conf={c:.3f}")

              empty = np.zeros((50, 50), dtype=np.uint8)
              d, c = classifier.recognise(empty, confidence_threshold=0.5)
              print(f"Pred (blank)         -> {d}, conf={c:.3f}")
    digit_extractor.py: |
      """
      Find and extract Sudoku grid cells from an image.
      """

      import os
      from pathlib import Path
      from typing import List, Tuple, Optional

      import cv2
      import numpy as np

      GRID_SIZE = 9
      DEFAULT_RECTIFIED_SIZE = 450


      def _order_points(pts: np.ndarray) -> np.ndarray:
          """Order four points as top-left, top-right, bottom-right, bottom-left."""
          pts = pts.reshape(4, 2).astype("float32")
          rect = np.zeros((4, 2), dtype="float32")
          s = pts.sum(axis=1)
          rect[0] = pts[np.argmin(s)]
          rect[2] = pts[np.argmax(s)]
          diff = pts[:, 1] - pts[:, 0]
          rect[1] = pts[np.argmin(diff)]
          rect[3] = pts[np.argmax(diff)]
          return rect


      def find_sudoku_grid_contour(
          img: np.ndarray,
          debug_dir: Optional[Path] = None
      ) -> np.ndarray:
          """
          Find the largest 4-point contour approximating the Sudoku grid boundary.
          """
          gray = (
              cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
              if img.ndim == 3 else img.copy()
          )

          if debug_dir:
              debug_dir.mkdir(parents=True, exist_ok=True)

          blur = cv2.GaussianBlur(gray, (7, 7), 0)
          thresh = cv2.adaptiveThreshold(
              blur, 255,
              cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
              cv2.THRESH_BINARY_INV,
              15, 4
          )
          closed = cv2.morphologyEx(
              thresh,
              cv2.MORPH_CLOSE,
              cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3)),
              iterations=2
          )

          contours, _ = cv2.findContours(
              closed, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE
          )
          contours = sorted(contours, key=cv2.contourArea, reverse=True)
          min_area = gray.size * 0.1

          for cnt in contours:
              if cv2.contourArea(cnt) < min_area:
                  break
              peri = cv2.arcLength(cnt, True)
              approx = cv2.approxPolyDP(cnt, 0.02 * peri, True)
              if len(approx) == 4 and cv2.isContourConvex(approx):
                  x, y, w, h = cv2.boundingRect(approx)
                  aspect = w / float(h)
                  if 0.8 < aspect < 1.2:
                      return approx.reshape(4, 2).astype("float32")

          raise ValueError("Sudoku grid contour not found.")


      def rectify_grid(
          img: np.ndarray,
          contour: np.ndarray,
          size: int = DEFAULT_RECTIFIED_SIZE
      ) -> Optional[np.ndarray]:
          """Perspective-correct the Sudoku grid to a square of given size."""
          try:
              src = _order_points(contour)
              dst = np.array([
                  [0, 0],
                  [size - 1, 0],
                  [size - 1, size - 1],
                  [0, size - 1],
              ], dtype="float32")
              mat = cv2.getPerspectiveTransform(src, dst)
              return cv2.warpPerspective(img, mat, (size, size))
          except cv2.error:
              return None


      def split_into_cells(
          rectified: np.ndarray
      ) -> Tuple[List[np.ndarray], np.ndarray]:
          """
          Split the rectified grid into GRID_SIZE × GRID_SIZE cell images.
          Returns (cells, rectified_image).
          """
          h, w = rectified.shape[:2]
          if h != w:
              size = max(h, w)
              rectified = cv2.resize(rectified, (size, size))
              h = w = size

          cell_sz = h // GRID_SIZE
          margin = int(cell_sz * 0.04)
          cells: List[np.ndarray] = []

          for row in range(GRID_SIZE):
              for col in range(GRID_SIZE):
                  y0 = row * cell_sz + margin
                  x0 = col * cell_sz + margin
                  y1 = (row + 1) * cell_sz - margin
                  x1 = (col + 1) * cell_sz - margin
                  if y0 >= y1 or x0 >= x1:
                      cell = np.zeros((cell_sz, cell_sz), rectified.dtype)
                  else:
                      cell = rectified[y0:y1, x0:x1]
                  cells.append(cell)

          return cells, rectified


      def extract_cells_from_image(
          img_or_path,
          size: int = DEFAULT_RECTIFIED_SIZE,
          debug: bool = False
      ) -> Tuple[Optional[List[np.ndarray]], Optional[np.ndarray], Optional[np.ndarray]]:
          """
          High-level function: read image, find grid, rectify, and split into cells.
          Returns (cells, rectified_image, contour) or (None, None, None) on failure.
          """
          if isinstance(img_or_path, (str, Path)):
              img = cv2.imread(str(img_or_path))
              if img is None:
                  return None, None, None
          elif isinstance(img_or_path, np.ndarray):
              img = img_or_path.copy()
          else:
              return None, None, None

          try:
              debug_dir = Path(f"debug_{os.getpid()}") if debug else None
              contour = find_sudoku_grid_contour(img, debug_dir)
              rectified = rectify_grid(img, contour, size=size)
              if rectified is None:
                  return None, None, None
              cells, rectified = split_into_cells(rectified)
              return cells, rectified, contour
          except Exception as exc:
              print(f"[Extractor] {exc}")
              return None, None, None
    sudoku_recogniser.py: |
      """
      Command-line utility to detect a Sudoku grid in an image and recognise its digits.
      """

      from __future__ import annotations

      import sys
      import time
      from pathlib import Path
      from typing import Tuple, Optional

      import cv2
      import numpy as np

      import digit_classifier
      from digit_extractor import GRID_SIZE, extract_cells_from_image

      FINAL_CONFIDENCE_THRESHOLD = 0.80


      def print_sudoku_grid(
          grid: np.ndarray,
          conf: Optional[np.ndarray] = None,
          threshold: float = FINAL_CONFIDENCE_THRESHOLD
      ) -> None:
          """Nicely print a 9×9 Sudoku grid, marking low‑confidence digits as '?'. """
          grid = np.asarray(grid)
          if grid.shape != (GRID_SIZE, GRID_SIZE):
              print("[print_sudoku_grid] invalid shape")
              return

          for r in range(GRID_SIZE):
              if r > 0 and r % 3 == 0:
                  print("|-----+-------+-----|")

              tokens = []
              for c in range(GRID_SIZE):
                  d = grid[r, c]
                  if d == 0:
                      tok = "."
                  else:
                      tok = str(d)
                      if conf is not None and conf[r, c] < threshold:
                          tok = "?"
                  tokens.append(tok)
                  if (c + 1) % 3 == 0 and c < GRID_SIZE - 1:
                      tokens.append("|")
              print(" ".join(tokens))
          print()


      def display_results_on_image(
          rectified: Optional[np.ndarray],
          grid: np.ndarray
      ) -> Optional[np.ndarray]:
          """
          Draw recognised digits onto the rectified grid image and return it.
          """
          if rectified is None:
              return None

          img = (
              cv2.cvtColor(rectified, cv2.COLOR_GRAY2BGR)
              if rectified.ndim == 2 else rectified.copy()
          )
          h, w = img.shape[:2]
          cell_h, cell_w = h // GRID_SIZE, w // GRID_SIZE

          for r in range(GRID_SIZE):
              for c in range(GRID_SIZE):
                  d = grid[r, c]
                  if d == 0:
                      continue
                  text = str(d)
                  (tw, th), _ = cv2.getTextSize(
                      text, cv2.FONT_HERSHEY_SIMPLEX, 1, 2
                  )
                  x = c * cell_w + (cell_w - tw) // 2
                  y = r * cell_h + (cell_h + th) // 2
                  cv2.putText(
                      img, text, (x, y),
                      cv2.FONT_HERSHEY_SIMPLEX,
                      1, (0, 255, 0), 2, cv2.LINE_AA
                  )
          return img


      def recognise_sudoku(
          img_path: Path,
          classifier: digit_classifier.DigitClassifier
      ) -> Tuple[np.ndarray, np.ndarray, Optional[np.ndarray]]:
          """
          Extract cells and run the classifier on each one.
          Returns (predicted_grid, confidence_grid, rectified_image).
          """
          print(f"Processing {img_path} ...")
          start = time.time()
          cells, rectified, _ = extract_cells_from_image(img_path)
          if cells is None or rectified is None:
              raise RuntimeError("Extraction failed.")

          pred = np.zeros((GRID_SIZE, GRID_SIZE), int)
          conf = np.zeros_like(pred, float)

          for i, cell in enumerate(cells):
              r, c = divmod(i, GRID_SIZE)
              d, cf = classifier.recognise(cell, confidence_threshold=0.1)
              conf[r, c] = cf
              if d != 0 and cf >= FINAL_CONFIDENCE_THRESHOLD:
                  pred[r, c] = d

          elapsed = time.time() - start
          print(f"Done in {elapsed:.2f}s")
          return pred, conf, rectified


      def main() -> None:
          if len(sys.argv) < 2:
              print("Usage: sudoku_recogniser.py <image_path>")
              sys.exit(0)

          img_path = Path(sys.argv[1])
          if not img_path.exists():
              print(f"Image not found: {img_path}")
              sys.exit(1)

          classifier = digit_classifier.DigitClassifier(model_path=digit_classifier.MODEL_FILENAME)
          if classifier.model is None:
              print("Model missing—training required.")
              classifier.train()

          grid, conf, rectified = recognise_sudoku(img_path, classifier)
          print_sudoku_grid(grid, conf)

          result_img = display_results_on_image(rectified, grid)
          if result_img is not None:
              cv2.imshow("Sudoku Recognition", result_img)
              cv2.waitKey(0)
              cv2.destroyAllWindows()


      if __name__ == "__main__":
          main()
    sudoku_renderer.py: |
      """
      Synthetic Sudoku image generator for on‑the‑fly training data.
      """

      import random
      from pathlib import Path
      from typing import Tuple, Optional

      import cv2
      import numpy as np
      import keras

      GRID_SIZE = 9
      BASE_IMAGE_SIZE = 1000
      CELL_SIZE = BASE_IMAGE_SIZE // GRID_SIZE


      def _order_points(pts: np.ndarray) -> np.ndarray:
          """Order four points as TL, TR, BR, BL."""
          pts = pts.reshape(4, 2).astype("float32")
          rect = np.zeros((4, 2), dtype="float32")
          s = pts.sum(axis=1)
          rect[0] = pts[np.argmin(s)]
          rect[2] = pts[np.argmax(s)]
          diff = pts[:, 1] - pts[:, 0]
          rect[1] = pts[np.argmin(diff)]
          rect[3] = pts[np.argmax(diff)]
          return rect


      def _load_mnist_digits() -> dict[int, list[np.ndarray]]:
          """
          Download MNIST once and bucket images by label for rendering.
          """
          (x_train, y_train), (x_test, y_test) = keras.datasets.mnist.load_data()
          images = np.concatenate([x_train, x_test])
          labels = np.concatenate([y_train, y_test])

          buckets: dict[int, list[np.ndarray]] = {i: [] for i in range(10)}
          for img, lbl in zip(images, labels):
              inv = cv2.bitwise_not(img)
              padded = cv2.copyMakeBorder(
                  inv, 4, 4, 4, 4,
                  cv2.BORDER_CONSTANT, value=255
              )
              buckets[int(lbl)].append(padded)
          return buckets


      class SudokuRenderer:
          """
          Render a random (or specified) Sudoku grid to a synthetic image.
          """

          def __init__(self) -> None:
              self.mnist_buckets: Optional[dict[int, list[np.ndarray]]] = None

          def _digit_source(self, digit: int) -> Tuple[Optional[np.ndarray], str]:
              if self.mnist_buckets is None:
                  self.mnist_buckets = _load_mnist_digits()

              sources = []
              if self.mnist_buckets[digit]:
                  sources.append("mnist")
              sources.append("font")
              choice = random.choice(sources)

              if choice == "mnist":
                  img = random.choice(self.mnist_buckets[digit])
                  if img.ndim == 2:
                      img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
                  return img, "mnist"
              return None, "font"

          def render_sudoku(
              self,
              grid_spec: Optional[list[list[int | None]]] = None,
              *,
              allow_empty: bool = True
          ) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
              """
              Generate a synthetic Sudoku image.
              Returns (image, ground_truth_grid, warped_corners).
              """
              if grid_spec is None:
                  gt = np.zeros((GRID_SIZE, GRID_SIZE), int)
                  for r in range(GRID_SIZE):
                      for c in range(GRID_SIZE):
                          if allow_empty and random.random() < 0.4:
                              continue
                          gt[r, c] = random.randint(1, 9)
              else:
                  gt = np.array([[d or 0 for d in row] for row in grid_spec], int)

              bg = tuple(random.randint(200, 240) for _ in range(3))
              img = np.full((BASE_IMAGE_SIZE, BASE_IMAGE_SIZE, 3), bg, np.uint8)

              # draw grid lines
              for i in range(GRID_SIZE + 1):
                  major = (i % 3 == 0)
                  thickness = random.randint(3 if major else 1, 5 if major else 3)
                  cv2.line(img, (0, i*CELL_SIZE), (BASE_IMAGE_SIZE, i*CELL_SIZE), (0, 0, 0), thickness)
                  cv2.line(img, (i*CELL_SIZE, 0), (i*CELL_SIZE, BASE_IMAGE_SIZE), (0, 0, 0), thickness)

              # draw digits
              for r in range(GRID_SIZE):
                  for c in range(GRID_SIZE):
                      d = gt[r, c]
                      if d == 0:
                          continue

                      src_img, src_type = self._digit_source(d)
                      scale = random.uniform(0.5, 0.8)
                      tgt = int(CELL_SIZE * scale)
                      center_x = c*CELL_SIZE + CELL_SIZE//2
                      center_y = r*CELL_SIZE + CELL_SIZE//2
                      dx = int(random.uniform(-0.1, 0.1)*CELL_SIZE)
                      dy = int(random.uniform(-0.1, 0.1)*CELL_SIZE)
                      cx, cy = center_x + dx, center_y + dy

                      if src_type == "mnist":
                          digit = cv2.resize(src_img, (tgt, tgt))
                          angle = random.uniform(-10, 10)
                          M = cv2.getRotationMatrix2D((tgt/2, tgt/2), angle, 1)
                          digit = cv2.warpAffine(
                              digit, M, (tgt, tgt),
                              borderMode=cv2.BORDER_CONSTANT, borderValue=(255,255,255)
                          )
                          mask = cv2.cvtColor(digit, cv2.COLOR_BGR2GRAY)
                          _, mask = cv2.threshold(mask, 250, 255, cv2.THRESH_BINARY_INV)

                          x0 = max(0, cx - tgt//2)
                          y0 = max(0, cy - tgt//2)
                          roi = img[y0:y0+tgt, x0:x0+tgt]
                          m_inv = cv2.bitwise_not(mask[:roi.shape[0], :roi.shape[1]])
                          bg_region = cv2.bitwise_and(roi, roi, mask=m_inv)
                          fg_region = cv2.bitwise_and(digit, digit, mask=mask[:roi.shape[0], :roi.shape[1]])
                          img[y0:y0+roi.shape[0], x0:x0+roi.shape[1]] = cv2.add(bg_region, fg_region)
                      else:
                          font = cv2.FONT_HERSHEY_SIMPLEX
                          thickness = random.randint(1, 3)
                          font_scale = cv2.getFontScaleFromHeight(font, tgt, thickness) * 0.8
                          text = str(d)
                          tw, th = cv2.getTextSize(text, font, font_scale, thickness)[0]
                          x = cx - tw//2
                          y = cy + th//2
                          cv2.putText(img, text, (x, y),
                                      font, font_scale, (0, 0, 0), thickness, cv2.LINE_AA)

              # add noise
              noise = np.random.normal(0, random.uniform(5,20), img.shape).astype(np.float32)
              noisy = np.clip(img.astype(np.float32) + noise, 0, 255).astype(np.uint8)

              # random perspective warp
              h, w = noisy.shape[:2]
              orig = np.array([[0,0],[w-1,0],[w-1,h-1],[0,h-1]], dtype="float32")
              shift = random.uniform(0.05, 0.2)
              max_dx, max_dy = w*shift, h*shift
              dst = np.array([
                  [random.uniform(0, max_dx), random.uniform(0, max_dy)],
                  [w-1-random.uniform(0, max_dx), random.uniform(0, max_dy)],
                  [w-1-random.uniform(-max_dx*0.2, max_dx), h-1-random.uniform(0, max_dy)],
                  [random.uniform(-max_dx*0.2, max_dx), h-1-random.uniform(0, max_dy)],
              ], dtype="float32")
              M = cv2.getPerspectiveTransform(orig, dst)
              out_w = int(dst[:,0].max()) + 1
              out_h = int(dst[:,1].max()) + 1
              warped = cv2.warpPerspective(
                  noisy, M, (out_w, out_h), borderMode=cv2.BORDER_REPLICATE
              )

              return warped, gt, dst


      def generate_and_save_test_example(
          prefix: str = "epoch_test_sudoku",
          force: bool = False
      ) -> Tuple[str, np.ndarray]:
          """
          Generate or load a fixed Sudoku test example for epoch callbacks.
          Returns (image_path, ground_truth_grid).
          """
          img_path = Path(f"{prefix}.png")
          gt_path = Path(f"{prefix}_gt.npy")

          if not force and img_path.exists() and gt_path.exists():
              return str(img_path), np.load(gt_path)

          renderer = SudokuRenderer()
          grid_spec = [
              [None, None, 3,    None, None, 6,    None, 8,    None],
              [8,    None, 1,    None, 3,    None, 5,    None, 4   ],
              [None, 4,    None, 8,    None, 7,    None, 1,    None],
              [1,    None, None, 4,    None, 5,    None, None, 9   ],
              [None, 7,    None, None, 2,    None, None, 4,    None],
              [5,    None, None, 7,    None, 1,    None, None, 3   ],
              [None, 8,    None, 5,    None, 3,    None, 9,    None],
              [7,    None, 4,    None, 9,    None, 1,    None, 8   ],
              [None, 1,    None, 6,    None, None, 4,    None, None],
          ]
          img, gt, _ = renderer.render_sudoku(grid_spec=grid_spec)
          cv2.imwrite(str(img_path), img)
          np.save(gt_path, gt)
          return str(img_path), gt
  diffs_applied_this_send: true
system:
  message: |2

    You are a helpful assistant.
    Respond in markdown format.
    Respond with a git diff patch for any modified or added files. Use the ```diff markdown code block.
    Avoid asking the user to clear their caches or do local configuration related stuff. That's rarely the cause of errors.
    If you ask them, and they reply with a compilation error, assume they've already done everything you suggested and move on.
    But try to avoid such suggestions. It's a cop out. It's like when tech support says 'Have you tried turning it off and on again?'.
    Try to actually fix the error instead.
  model:
    - o3
  code_completion_model:
    - o3
  commit_message_model:
    - gemini/gemini-2.5-flash-preview-04-17
  max_completion_tokens:
  temperature: 0.0
  apply_mode: git
messages:
  - user: |-
      ```python 'digit_classifier.py'
      """
      Convolutional‐NN based digit classifier for Sudoku recognition.
      """

      import os
      import random
      import gc
      from pathlib import Path
      from typing import Callable, Generator, Tuple, Optional

      import cv2
      import numpy as np
      import keras
      from keras import callbacks, layers, models
      import torch

      # use Torch as Keras backend
      os.environ["KERAS_BACKEND"] = "torch"

      from sudoku_renderer import SudokuRenderer, generate_and_save_test_example
      from digit_extractor import GRID_SIZE, extract_cells_from_image, rectify_grid, split_into_cells
      from sudoku_recogniser import FINAL_CONFIDENCE_THRESHOLD, print_sudoku_grid

      MODEL_FILENAME = "sudoku_digit_classifier_cnn.keras"
      MODEL_INPUT_SHAPE = (28, 28, 1)
      NUM_CLASSES = 11        # digits 0–9 plus one “empty” class
      EMPTY_LABEL = 10
      TARGET_CELL_CONTENT_SIZE = 24
      TARGET_DIGIT_RATIO = 1.5

      EPOCHS = 20
      STEPS_PER_EPOCH = 150
      BATCH_SIZE = 128
      VALIDATION_STEPS = 50

      DataBatch = Tuple[np.ndarray, np.ndarray]


      def sudoku_data_generator(
          renderer: SudokuRenderer,
          batch_size: int,
          preprocess_func: Callable[[np.ndarray], Optional[np.ndarray]],
          input_size: Tuple[int, int, int],
          target_digit_ratio: float = TARGET_DIGIT_RATIO,
      ) -> Generator[DataBatch, None, None]:
          """
          Yield balanced batches of (cell_image, label) for training.
          """
          total_cells = GRID_SIZE * GRID_SIZE
          target_digits = int(batch_size * target_digit_ratio / (1 + target_digit_ratio))
          target_empty = batch_size - target_digits
          input_h, input_w = input_size[:2]

          while True:
              x_list, y_list = [], []
              n_digits = n_empty = 0
              attempts = 0
              max_attempts = batch_size * 4

              while len(x_list) < batch_size and attempts < max_attempts:
                  attempts += 1
                  allow_empty = (random.random() < 0.8)
                  img, gt_grid, corners = renderer.render_sudoku(allow_empty=allow_empty)
                  if img is None or corners is None:
                      continue

                  rectified = rectify_grid(img, corners)
                  if rectified is None:
                      continue

                  cells, _ = split_into_cells(rectified)
                  if len(cells) != total_cells:
                      continue

                  gt_flat = gt_grid.flatten()
                  indices = list(range(total_cells))
                  random.shuffle(indices)

                  for idx in indices:
                      cell = cells[idx]
                      label = EMPTY_LABEL if gt_flat[idx] == 0 else gt_flat[idx]
                      is_empty = (label == EMPTY_LABEL)

                      if is_empty and n_empty >= target_empty:
                          continue
                      if not is_empty and n_digits >= target_digits:
                          continue

                      processed = preprocess_func(cell)
                      if processed is None or processed.shape != (input_h, input_w):
                          continue

                      x_list.append(processed)
                      y_list.append(label)
                      if is_empty:
                          n_empty += 1
                      else:
                          n_digits += 1

                      if len(x_list) >= batch_size:
                          break

              if not x_list:
                  continue

              x_arr = np.array(x_list, dtype="float32")[..., np.newaxis]
              y_arr = np.array(y_list, dtype="int64")
              perm = np.random.permutation(len(y_arr))
              yield x_arr[perm], y_arr[perm]

              del x_list, y_list, x_arr, y_arr
              gc.collect()


      class EpochTestCallback(callbacks.Callback):
          """
          Evaluate the model on a fixed Sudoku example after every `frequency` epochs.
          """

          def __init__(
              self,
              test_img_path: Path,
              gt_grid: np.ndarray,
              classifier: "DigitClassifier",
              frequency: int = 1,
          ) -> None:
              super().__init__()
              self.frequency = max(1, frequency)
              self.gt_grid = gt_grid
              self.classifier = classifier

              cells, _, _ = extract_cells_from_image(test_img_path, debug=False)
              if not cells or len(cells) != GRID_SIZE * GRID_SIZE:
                  self.preprocessed = None
                  print("[Callback] Test image preparation failed—callback disabled.")
                  return

              processed = []
              for cell in cells:
                  proc = classifier._preprocess_cell_for_model(cell)
                  if proc is None:
                      proc = np.zeros(classifier._model_input_size, dtype="float32")
                  processed.append(proc)

              self.preprocessed = np.array(processed, dtype="float32")[..., np.newaxis]

          def on_epoch_end(self, epoch: int, logs=None) -> None:
              if self.preprocessed is None or (epoch + 1) % self.frequency != 0:
                  return

              preds = self.model.predict(self.preprocessed, verbose=0)
              idxs = np.argmax(preds, axis=1)
              confs = np.max(preds, axis=1)

              final = []
              for idx, conf in zip(idxs, confs):
                  digit = idx if (idx != EMPTY_LABEL and conf >= FINAL_CONFIDENCE_THRESHOLD) else 0
                  final.append(digit)

              pred_grid = np.array(final).reshape(GRID_SIZE, GRID_SIZE)
              conf_grid = confs.reshape(GRID_SIZE, GRID_SIZE)

              print(f"\n--- Epoch {epoch+1} Test Example ---")
              print("Ground truth:")
              print_sudoku_grid(self.gt_grid, threshold=1.1)
              print("Prediction:")
              print_sudoku_grid(pred_grid, conf_grid, threshold=FINAL_CONFIDENCE_THRESHOLD)

              correct = np.sum(pred_grid == self.gt_grid)
              total = GRID_SIZE * GRID_SIZE
              print(f"Accuracy: {correct}/{total} ({correct/total:.4f})")
              print("--- End ---\n")


      class DigitClassifier:
          """
          Handles loading, training, and inference of the digit classification model.
          """

          def __init__(
              self,
              model_path: Optional[str | Path] = None,
              training_required: bool = False,
          ) -> None:
              self.model_path = Path(model_path) if model_path else Path(MODEL_FILENAME)
              self.model: Optional[keras.Model] = None
              self._model_input_size = MODEL_INPUT_SHAPE[:2]

              if not training_required and self.model_path.exists():
                  try:
                      self.model = keras.models.load_model(self.model_path)
                      loaded_shape = self.model.input_shape[1:3]
                      if loaded_shape != self._model_input_size:
                          print(
                              f"[Warning] Model input shape {loaded_shape} "
                              f"!= expected {self._model_input_size}"
                          )
                      print("Model loaded.")
                  except Exception as exc:
                      print(f"[Error] Could not load model: {exc}")

          def _build_cnn_model(self) -> keras.Model:
              """13‑layer SimpleNet backbone (all 3×3 convs)."""
              cfg_filters   = [32, 32,     # block‑1
                               64, 64,     # block‑2
                               96, 96, 96, # block‑3
                               128,128,128,128,   # block‑4
                               192,192]    # block‑5 (inc. optional 1×1 later)
              pool_after_id = {1, 3, 6, 10}       # indices after which we pool

              inputs = keras.Input(shape=MODEL_INPUT_SHAPE)
              x = inputs
              for i, f in enumerate(cfg_filters):
                  # ordinary 3×3 conv
                  x = layers.Conv2D(f, 3, padding="same", use_bias=False)(x)
                  x = layers.BatchNormalization()(x)
                  x = layers.ReLU()(x)

                  # 2×2 max‑pool **after** the i‑th conv if requested
                  if i in pool_after_id:
                      x = layers.MaxPooling2D(pool_size=2)(x)

              # optional 1×1 bottleneck (kept trainable but parameter‑cheap)
              x = layers.Conv2D(256, 1, use_bias=False)(x)
              x = layers.BatchNormalization()(x)
              x = layers.ReLU()(x)

              # global spatial pooling → soft‑max output
              x = layers.GlobalAveragePooling2D()(x)
              outputs = layers.Dense(NUM_CLASSES, activation="softmax")(x)

              model = keras.Model(inputs, outputs, name="simplenet_digits")
              model.compile(
                  optimizer=keras.optimizers.Adam(1e-3),
                  loss      ="sparse_categorical_crossentropy",
                  metrics   =["accuracy"],
              )
              model.summary()         # shows ~5 M parameters → on‑par with paper
              return model

          def _preprocess_cell_for_model(self, cell: np.ndarray) -> Optional[np.ndarray]:
              """
              Binarize, crop, center, resize, and normalize a single cell image.
              Returns a 2D float32 array of shape `_model_input_size`, or None.
              """
              if cell is None or cell.size < 10:
                  return None

              gray = (
                  cv2.cvtColor(cell, cv2.COLOR_BGR2GRAY)
                  if cell.ndim == 3 else cell.copy()
              )

              blk = max(3, min(gray.shape) // 4) | 1
              try:
                  thresh = cv2.adaptiveThreshold(
                      gray, 255,
                      cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                      cv2.THRESH_BINARY_INV,
                      blk, 7
                  )
              except cv2.error:
                  return None

              coords = cv2.findNonZero(thresh)
              if coords is None:
                  return None

              x, y, w, h = cv2.boundingRect(coords)
              if w == 0 or h == 0:
                  return None

              roi = thresh[y : y+h, x : x+w]
              scale = min(
                  TARGET_CELL_CONTENT_SIZE / w,
                  TARGET_CELL_CONTENT_SIZE / h,
              )
              new_w = max(1, int(w * scale))
              new_h = max(1, int(h * scale))
              resized = cv2.resize(roi, (new_w, new_h), interpolation=cv2.INTER_AREA)

              canvas = np.zeros(self._model_input_size, dtype=np.uint8)
              top = (self._model_input_size[0] - new_h) // 2
              left = (self._model_input_size[1] - new_w) // 2
              canvas[top:top+new_h, left:left+new_w] = resized

              return canvas.astype("float32") / 255.0

          def train(
              self,
              epochs: int = EPOCHS,
              steps_per_epoch: int = STEPS_PER_EPOCH,
              batch_size: int = BATCH_SIZE,
              validation_steps: int = VALIDATION_STEPS,
          ) -> None:
              """Train the model using synthetic Sudoku data."""
              print(
                  f"\nTraining parameters: "
                  f"epochs={epochs}, steps_per_epoch={steps_per_epoch}, "
                  f"batch_size={batch_size}, validation_steps={validation_steps}"
              )

              try:
                  test_img, test_gt = generate_and_save_test_example()
                  epoch_test_cb = EpochTestCallback(test_img, test_gt, self)
              except Exception as exc:
                  print(f"[Warning] Could not set up epoch test callback: {exc}")
                  epoch_test_cb = None

              train_gen = sudoku_data_generator(
                  SudokuRenderer(),
                  batch_size,
                  self._preprocess_cell_for_model,
                  MODEL_INPUT_SHAPE,
              )
              val_gen = sudoku_data_generator(
                  SudokuRenderer(),
                  batch_size,
                  self._preprocess_cell_for_model,
                  MODEL_INPUT_SHAPE,
              )

              if self.model is None:
                  self.model = self._build_cnn_model()

              cbs = [
                  callbacks.EarlyStopping(
                      monitor="val_loss", patience=5,
                      restore_best_weights=True, verbose=1
                  ),
                  callbacks.ModelCheckpoint(
                      filepath=self.model_path,
                      monitor="val_loss", save_best_only=True, verbose=1
                  ),
                  callbacks.ReduceLROnPlateau(
                      monitor="val_loss", factor=0.2,
                      patience=3, min_lr=1e-6, verbose=1
                  ),
              ]
              if epoch_test_cb and epoch_test_cb.preprocessed is not None:
                  cbs.append(epoch_test_cb)

              self.model.fit(
                  train_gen,
                  epochs=epochs,
                  steps_per_epoch=steps_per_epoch,
                  validation_data=val_gen,
                  validation_steps=validation_steps,
                  callbacks=cbs,
                  verbose=1,
              )

              print("\nFinal evaluation:")
              loss, acc = self.model.evaluate(
                  sudoku_data_generator(
                      SudokuRenderer(),
                      batch_size,
                      self._preprocess_cell_for_model,
                      MODEL_INPUT_SHAPE,
                  ),
                  steps=validation_steps,
                  verbose=1,
              )
              print(f"Validation loss={loss:.4f}, accuracy={acc:.4f}")

              self.model.save(self.model_path)
              del train_gen, val_gen
              gc.collect()

          @torch.no_grad()
          def recognise(
              self,
              cell: np.ndarray,
              confidence_threshold: float = 0.7,
          ) -> Tuple[int, float]:
              """
              Predict the digit in a single cell.
              Returns (digit, confidence). digit=0 indicates empty/uncertain.
              """
              if self.model is None:
                  return 0, 0.0

              proc = self._preprocess_cell_for_model(cell)
              if proc is None:
                  return 0, 0.0

              x = proc[np.newaxis, ..., np.newaxis]
              x_tensor = torch.from_numpy(x).float()
              probs = self.model(x_tensor, training=False)[0]
              if isinstance(probs, torch.Tensor):
                  probs = probs.cpu().numpy()

              idx = int(np.argmax(probs))
              conf = float(probs[idx])
              if idx == EMPTY_LABEL or conf < confidence_threshold:
                  return 0, conf
              return idx, conf


      if __name__ == "__main__":
          FORCE_TRAIN = False
          if FORCE_TRAIN and Path(MODEL_FILENAME).exists():
              Path(MODEL_FILENAME).unlink()

          classifier = DigitClassifier(training_required=FORCE_TRAIN)
          if classifier.model is None:
              classifier.train()

          if classifier.model:
              print("\nQuick dummy test:")
              dummy = np.zeros((50, 50), dtype=np.uint8)
              cv2.line(dummy, (25, 10), (25, 40), 255, 3)
              d, c = classifier.recognise(dummy, confidence_threshold=0.5)
              print(f"Pred (vertical line) -> {d}, conf={c:.3f}")

              empty = np.zeros((50, 50), dtype=np.uint8)
              d, c = classifier.recognise(empty, confidence_threshold=0.5)
              print(f"Pred (blank)         -> {d}, conf={c:.3f}")

      ```
    metadata:
      filename: digit_classifier.py
  - user: |-
      ```python 'digit_extractor.py'
      """
      Find and extract Sudoku grid cells from an image.
      """

      import os
      from pathlib import Path
      from typing import List, Tuple, Optional

      import cv2
      import numpy as np

      GRID_SIZE = 9
      DEFAULT_RECTIFIED_SIZE = 450


      def _order_points(pts: np.ndarray) -> np.ndarray:
          """Order four points as top-left, top-right, bottom-right, bottom-left."""
          pts = pts.reshape(4, 2).astype("float32")
          rect = np.zeros((4, 2), dtype="float32")
          s = pts.sum(axis=1)
          rect[0] = pts[np.argmin(s)]
          rect[2] = pts[np.argmax(s)]
          diff = pts[:, 1] - pts[:, 0]
          rect[1] = pts[np.argmin(diff)]
          rect[3] = pts[np.argmax(diff)]
          return rect


      def find_sudoku_grid_contour(
          img: np.ndarray,
          debug_dir: Optional[Path] = None
      ) -> np.ndarray:
          """
          Find the largest 4-point contour approximating the Sudoku grid boundary.
          """
          gray = (
              cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
              if img.ndim == 3 else img.copy()
          )

          if debug_dir:
              debug_dir.mkdir(parents=True, exist_ok=True)

          blur = cv2.GaussianBlur(gray, (7, 7), 0)
          thresh = cv2.adaptiveThreshold(
              blur, 255,
              cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
              cv2.THRESH_BINARY_INV,
              15, 4
          )
          closed = cv2.morphologyEx(
              thresh,
              cv2.MORPH_CLOSE,
              cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3)),
              iterations=2
          )

          contours, _ = cv2.findContours(
              closed, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE
          )
          contours = sorted(contours, key=cv2.contourArea, reverse=True)
          min_area = gray.size * 0.1

          for cnt in contours:
              if cv2.contourArea(cnt) < min_area:
                  break
              peri = cv2.arcLength(cnt, True)
              approx = cv2.approxPolyDP(cnt, 0.02 * peri, True)
              if len(approx) == 4 and cv2.isContourConvex(approx):
                  x, y, w, h = cv2.boundingRect(approx)
                  aspect = w / float(h)
                  if 0.8 < aspect < 1.2:
                      return approx.reshape(4, 2).astype("float32")

          raise ValueError("Sudoku grid contour not found.")


      def rectify_grid(
          img: np.ndarray,
          contour: np.ndarray,
          size: int = DEFAULT_RECTIFIED_SIZE
      ) -> Optional[np.ndarray]:
          """Perspective-correct the Sudoku grid to a square of given size."""
          try:
              src = _order_points(contour)
              dst = np.array([
                  [0, 0],
                  [size - 1, 0],
                  [size - 1, size - 1],
                  [0, size - 1],
              ], dtype="float32")
              mat = cv2.getPerspectiveTransform(src, dst)
              return cv2.warpPerspective(img, mat, (size, size))
          except cv2.error:
              return None


      def split_into_cells(
          rectified: np.ndarray
      ) -> Tuple[List[np.ndarray], np.ndarray]:
          """
          Split the rectified grid into GRID_SIZE × GRID_SIZE cell images.
          Returns (cells, rectified_image).
          """
          h, w = rectified.shape[:2]
          if h != w:
              size = max(h, w)
              rectified = cv2.resize(rectified, (size, size))
              h = w = size

          cell_sz = h // GRID_SIZE
          margin = int(cell_sz * 0.04)
          cells: List[np.ndarray] = []

          for row in range(GRID_SIZE):
              for col in range(GRID_SIZE):
                  y0 = row * cell_sz + margin
                  x0 = col * cell_sz + margin
                  y1 = (row + 1) * cell_sz - margin
                  x1 = (col + 1) * cell_sz - margin
                  if y0 >= y1 or x0 >= x1:
                      cell = np.zeros((cell_sz, cell_sz), rectified.dtype)
                  else:
                      cell = rectified[y0:y1, x0:x1]
                  cells.append(cell)

          return cells, rectified


      def extract_cells_from_image(
          img_or_path,
          size: int = DEFAULT_RECTIFIED_SIZE,
          debug: bool = False
      ) -> Tuple[Optional[List[np.ndarray]], Optional[np.ndarray], Optional[np.ndarray]]:
          """
          High-level function: read image, find grid, rectify, and split into cells.
          Returns (cells, rectified_image, contour) or (None, None, None) on failure.
          """
          if isinstance(img_or_path, (str, Path)):
              img = cv2.imread(str(img_or_path))
              if img is None:
                  return None, None, None
          elif isinstance(img_or_path, np.ndarray):
              img = img_or_path.copy()
          else:
              return None, None, None

          try:
              debug_dir = Path(f"debug_{os.getpid()}") if debug else None
              contour = find_sudoku_grid_contour(img, debug_dir)
              rectified = rectify_grid(img, contour, size=size)
              if rectified is None:
                  return None, None, None
              cells, rectified = split_into_cells(rectified)
              return cells, rectified, contour
          except Exception as exc:
              print(f"[Extractor] {exc}")
              return None, None, None

      ```
    metadata:
      filename: digit_extractor.py
  - user: |-
      ```python 'sudoku_recogniser.py'
      """
      Command-line utility to detect a Sudoku grid in an image and recognise its digits.
      """

      from __future__ import annotations

      import sys
      import time
      from pathlib import Path
      from typing import Tuple, Optional

      import cv2
      import numpy as np

      import digit_classifier
      from digit_extractor import GRID_SIZE, extract_cells_from_image

      FINAL_CONFIDENCE_THRESHOLD = 0.80


      def print_sudoku_grid(
          grid: np.ndarray,
          conf: Optional[np.ndarray] = None,
          threshold: float = FINAL_CONFIDENCE_THRESHOLD
      ) -> None:
          """Nicely print a 9×9 Sudoku grid, marking low‑confidence digits as '?'. """
          grid = np.asarray(grid)
          if grid.shape != (GRID_SIZE, GRID_SIZE):
              print("[print_sudoku_grid] invalid shape")
              return

          for r in range(GRID_SIZE):
              if r > 0 and r % 3 == 0:
                  print("|-----+-------+-----|")

              tokens = []
              for c in range(GRID_SIZE):
                  d = grid[r, c]
                  if d == 0:
                      tok = "."
                  else:
                      tok = str(d)
                      if conf is not None and conf[r, c] < threshold:
                          tok = "?"
                  tokens.append(tok)
                  if (c + 1) % 3 == 0 and c < GRID_SIZE - 1:
                      tokens.append("|")
              print(" ".join(tokens))
          print()


      def display_results_on_image(
          rectified: Optional[np.ndarray],
          grid: np.ndarray
      ) -> Optional[np.ndarray]:
          """
          Draw recognised digits onto the rectified grid image and return it.
          """
          if rectified is None:
              return None

          img = (
              cv2.cvtColor(rectified, cv2.COLOR_GRAY2BGR)
              if rectified.ndim == 2 else rectified.copy()
          )
          h, w = img.shape[:2]
          cell_h, cell_w = h // GRID_SIZE, w // GRID_SIZE

          for r in range(GRID_SIZE):
              for c in range(GRID_SIZE):
                  d = grid[r, c]
                  if d == 0:
                      continue
                  text = str(d)
                  (tw, th), _ = cv2.getTextSize(
                      text, cv2.FONT_HERSHEY_SIMPLEX, 1, 2
                  )
                  x = c * cell_w + (cell_w - tw) // 2
                  y = r * cell_h + (cell_h + th) // 2
                  cv2.putText(
                      img, text, (x, y),
                      cv2.FONT_HERSHEY_SIMPLEX,
                      1, (0, 255, 0), 2, cv2.LINE_AA
                  )
          return img


      def recognise_sudoku(
          img_path: Path,
          classifier: digit_classifier.DigitClassifier
      ) -> Tuple[np.ndarray, np.ndarray, Optional[np.ndarray]]:
          """
          Extract cells and run the classifier on each one.
          Returns (predicted_grid, confidence_grid, rectified_image).
          """
          print(f"Processing {img_path} ...")
          start = time.time()
          cells, rectified, _ = extract_cells_from_image(img_path)
          if cells is None or rectified is None:
              raise RuntimeError("Extraction failed.")

          pred = np.zeros((GRID_SIZE, GRID_SIZE), int)
          conf = np.zeros_like(pred, float)

          for i, cell in enumerate(cells):
              r, c = divmod(i, GRID_SIZE)
              d, cf = classifier.recognise(cell, confidence_threshold=0.1)
              conf[r, c] = cf
              if d != 0 and cf >= FINAL_CONFIDENCE_THRESHOLD:
                  pred[r, c] = d

          elapsed = time.time() - start
          print(f"Done in {elapsed:.2f}s")
          return pred, conf, rectified


      def main() -> None:
          if len(sys.argv) < 2:
              print("Usage: sudoku_recogniser.py <image_path>")
              sys.exit(0)

          img_path = Path(sys.argv[1])
          if not img_path.exists():
              print(f"Image not found: {img_path}")
              sys.exit(1)

          classifier = digit_classifier.DigitClassifier(model_path=digit_classifier.MODEL_FILENAME)
          if classifier.model is None:
              print("Model missing—training required.")
              classifier.train()

          grid, conf, rectified = recognise_sudoku(img_path, classifier)
          print_sudoku_grid(grid, conf)

          result_img = display_results_on_image(rectified, grid)
          if result_img is not None:
              cv2.imshow("Sudoku Recognition", result_img)
              cv2.waitKey(0)
              cv2.destroyAllWindows()


      if __name__ == "__main__":
          main()

      ```
    metadata:
      filename: sudoku_recogniser.py
  - user: |-
      ```python 'sudoku_renderer.py'
      """
      Synthetic Sudoku image generator for on‑the‑fly training data.
      """

      import random
      from pathlib import Path
      from typing import Tuple, Optional

      import cv2
      import numpy as np
      import keras

      GRID_SIZE = 9
      BASE_IMAGE_SIZE = 1000
      CELL_SIZE = BASE_IMAGE_SIZE // GRID_SIZE


      def _order_points(pts: np.ndarray) -> np.ndarray:
          """Order four points as TL, TR, BR, BL."""
          pts = pts.reshape(4, 2).astype("float32")
          rect = np.zeros((4, 2), dtype="float32")
          s = pts.sum(axis=1)
          rect[0] = pts[np.argmin(s)]
          rect[2] = pts[np.argmax(s)]
          diff = pts[:, 1] - pts[:, 0]
          rect[1] = pts[np.argmin(diff)]
          rect[3] = pts[np.argmax(diff)]
          return rect


      def _load_mnist_digits() -> dict[int, list[np.ndarray]]:
          """
          Download MNIST once and bucket images by label for rendering.
          """
          (x_train, y_train), (x_test, y_test) = keras.datasets.mnist.load_data()
          images = np.concatenate([x_train, x_test])
          labels = np.concatenate([y_train, y_test])

          buckets: dict[int, list[np.ndarray]] = {i: [] for i in range(10)}
          for img, lbl in zip(images, labels):
              inv = cv2.bitwise_not(img)
              padded = cv2.copyMakeBorder(
                  inv, 4, 4, 4, 4,
                  cv2.BORDER_CONSTANT, value=255
              )
              buckets[int(lbl)].append(padded)
          return buckets


      class SudokuRenderer:
          """
          Render a random (or specified) Sudoku grid to a synthetic image.
          """

          def __init__(self) -> None:
              self.mnist_buckets: Optional[dict[int, list[np.ndarray]]] = None

          def _digit_source(self, digit: int) -> Tuple[Optional[np.ndarray], str]:
              if self.mnist_buckets is None:
                  self.mnist_buckets = _load_mnist_digits()

              sources = []
              if self.mnist_buckets[digit]:
                  sources.append("mnist")
              sources.append("font")
              choice = random.choice(sources)

              if choice == "mnist":
                  img = random.choice(self.mnist_buckets[digit])
                  if img.ndim == 2:
                      img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
                  return img, "mnist"
              return None, "font"

          def render_sudoku(
              self,
              grid_spec: Optional[list[list[int | None]]] = None,
              *,
              allow_empty: bool = True
          ) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
              """
              Generate a synthetic Sudoku image.
              Returns (image, ground_truth_grid, warped_corners).
              """
              if grid_spec is None:
                  gt = np.zeros((GRID_SIZE, GRID_SIZE), int)
                  for r in range(GRID_SIZE):
                      for c in range(GRID_SIZE):
                          if allow_empty and random.random() < 0.4:
                              continue
                          gt[r, c] = random.randint(1, 9)
              else:
                  gt = np.array([[d or 0 for d in row] for row in grid_spec], int)

              bg = tuple(random.randint(200, 240) for _ in range(3))
              img = np.full((BASE_IMAGE_SIZE, BASE_IMAGE_SIZE, 3), bg, np.uint8)

              # draw grid lines
              for i in range(GRID_SIZE + 1):
                  major = (i % 3 == 0)
                  thickness = random.randint(3 if major else 1, 5 if major else 3)
                  cv2.line(img, (0, i*CELL_SIZE), (BASE_IMAGE_SIZE, i*CELL_SIZE), (0, 0, 0), thickness)
                  cv2.line(img, (i*CELL_SIZE, 0), (i*CELL_SIZE, BASE_IMAGE_SIZE), (0, 0, 0), thickness)

              # draw digits
              for r in range(GRID_SIZE):
                  for c in range(GRID_SIZE):
                      d = gt[r, c]
                      if d == 0:
                          continue

                      src_img, src_type = self._digit_source(d)
                      scale = random.uniform(0.5, 0.8)
                      tgt = int(CELL_SIZE * scale)
                      center_x = c*CELL_SIZE + CELL_SIZE//2
                      center_y = r*CELL_SIZE + CELL_SIZE//2
                      dx = int(random.uniform(-0.1, 0.1)*CELL_SIZE)
                      dy = int(random.uniform(-0.1, 0.1)*CELL_SIZE)
                      cx, cy = center_x + dx, center_y + dy

                      if src_type == "mnist":
                          digit = cv2.resize(src_img, (tgt, tgt))
                          angle = random.uniform(-10, 10)
                          M = cv2.getRotationMatrix2D((tgt/2, tgt/2), angle, 1)
                          digit = cv2.warpAffine(
                              digit, M, (tgt, tgt),
                              borderMode=cv2.BORDER_CONSTANT, borderValue=(255,255,255)
                          )
                          mask = cv2.cvtColor(digit, cv2.COLOR_BGR2GRAY)
                          _, mask = cv2.threshold(mask, 250, 255, cv2.THRESH_BINARY_INV)

                          x0 = max(0, cx - tgt//2)
                          y0 = max(0, cy - tgt//2)
                          roi = img[y0:y0+tgt, x0:x0+tgt]
                          m_inv = cv2.bitwise_not(mask[:roi.shape[0], :roi.shape[1]])
                          bg_region = cv2.bitwise_and(roi, roi, mask=m_inv)
                          fg_region = cv2.bitwise_and(digit, digit, mask=mask[:roi.shape[0], :roi.shape[1]])
                          img[y0:y0+roi.shape[0], x0:x0+roi.shape[1]] = cv2.add(bg_region, fg_region)
                      else:
                          font = cv2.FONT_HERSHEY_SIMPLEX
                          thickness = random.randint(1, 3)
                          font_scale = cv2.getFontScaleFromHeight(font, tgt, thickness) * 0.8
                          text = str(d)
                          tw, th = cv2.getTextSize(text, font, font_scale, thickness)[0]
                          x = cx - tw//2
                          y = cy + th//2
                          cv2.putText(img, text, (x, y),
                                      font, font_scale, (0, 0, 0), thickness, cv2.LINE_AA)

              # add noise
              noise = np.random.normal(0, random.uniform(5,20), img.shape).astype(np.float32)
              noisy = np.clip(img.astype(np.float32) + noise, 0, 255).astype(np.uint8)

              # random perspective warp
              h, w = noisy.shape[:2]
              orig = np.array([[0,0],[w-1,0],[w-1,h-1],[0,h-1]], dtype="float32")
              shift = random.uniform(0.05, 0.2)
              max_dx, max_dy = w*shift, h*shift
              dst = np.array([
                  [random.uniform(0, max_dx), random.uniform(0, max_dy)],
                  [w-1-random.uniform(0, max_dx), random.uniform(0, max_dy)],
                  [w-1-random.uniform(-max_dx*0.2, max_dx), h-1-random.uniform(0, max_dy)],
                  [random.uniform(-max_dx*0.2, max_dx), h-1-random.uniform(0, max_dy)],
              ], dtype="float32")
              M = cv2.getPerspectiveTransform(orig, dst)
              out_w = int(dst[:,0].max()) + 1
              out_h = int(dst[:,1].max()) + 1
              warped = cv2.warpPerspective(
                  noisy, M, (out_w, out_h), borderMode=cv2.BORDER_REPLICATE
              )

              return warped, gt, dst


      def generate_and_save_test_example(
          prefix: str = "epoch_test_sudoku",
          force: bool = False
      ) -> Tuple[str, np.ndarray]:
          """
          Generate or load a fixed Sudoku test example for epoch callbacks.
          Returns (image_path, ground_truth_grid).
          """
          img_path = Path(f"{prefix}.png")
          gt_path = Path(f"{prefix}_gt.npy")

          if not force and img_path.exists() and gt_path.exists():
              return str(img_path), np.load(gt_path)

          renderer = SudokuRenderer()
          grid_spec = [
              [None, None, 3,    None, None, 6,    None, 8,    None],
              [8,    None, 1,    None, 3,    None, 5,    None, 4   ],
              [None, 4,    None, 8,    None, 7,    None, 1,    None],
              [1,    None, None, 4,    None, 5,    None, None, 9   ],
              [None, 7,    None, None, 2,    None, None, 4,    None],
              [5,    None, None, 7,    None, 1,    None, None, 3   ],
              [None, 8,    None, 5,    None, 3,    None, 9,    None],
              [7,    None, 4,    None, 9,    None, 1,    None, 8   ],
              [None, 1,    None, 6,    None, None, 4,    None, None],
          ]
          img, gt, _ = renderer.render_sudoku(grid_spec=grid_spec)
          cv2.imwrite(str(img_path), img)
          np.save(gt_path, gt)
          return str(img_path), gt

      ```
    metadata:
      filename: sudoku_renderer.py
  - user: Add a file that creates example images, ie a few (say, 10) example sudokus,
      and extracts the digits for each of them, putting each into a separate subfolder.
      The goal is to show the stages of the data pipeline.
    metadata:
  - assistant: "Response(id='resp_6803a68713648191b58501b2939533f70fc69ad2bb3042e3',
      created_at=1745069703.0, error=None, incomplete_details=None, instructions=None,
      metadata={}, model='o3-2025-04-16', object='response', output=[ResponseReasoningItem(id='rs_6803a68856bc8191b7ca462417a0960b0fc69ad2bb3042e3',
      summary=[], type='reasoning', status=None), ResponseOutputMessage(id='msg_6803a68e91cc8191879a59c0189a73dc0fc69ad2bb3042e3',
      content=[ResponseOutputText(annotations=[], text='```diff\\n*** Begin Patch\\
      n*** Add File: generate_pipeline_examples.py\\n+\"\"\"\\n+generate_pipeline_examples.py\\
      n+=============================\\n+Utility script that demonstrates the full
      synthetic‑data pipeline:\\n+\\n+1.  Create a handful of synthetic Sudoku photographs
      with `SudokuRenderer`.\\n+2.  Run the extractor so we get\\n+      • the perspective‑rectified
      board, and\\n+      • the 81 individual cell crops.\\n+3.  Save everything into
      clearly‑structured sub‑folders so it can be inspected\\n+   with any ordinary
      image viewer.\\n+\\n+Resulting folder structure (for N\\xa0=\\xa010):\\n+\\\
      n+    pipeline_examples/\\n+        00/\\n+            synthetic.png       –
      raw synthetic photo\\n+            rectified.png       – perspective‑corrected
      board\\n+            gt_grid.npy         – 9×9 ground‑truth digit array\\n+\
      \            cell_00.png … cell_80.png\\n+        01/\\n+            …\\n+ \
      \       …\\n+\\n+Run:\\n+    python generate_pipeline_examples.py   # defaults
      to 10 examples\\n+    python generate_pipeline_examples.py 20 out_dir\\n+\"\"\
      \"\\n+\\n+from __future__ import annotations\\n+\\n+import sys\\n+from pathlib
      import Path\\n+\\n+import cv2\\n+import numpy as np\\n+\\n+from sudoku_renderer
      import SudokuRenderer\\n+from digit_extractor import extract_cells_from_image,
      GRID_SIZE\\n+\\n+# ---------------------------------------------------------------------------
      #\\n+# Configuration\\n+# ---------------------------------------------------------------------------
      #\\n+\\n+DEFAULT_N_EXAMPLES = 10\\n+DEFAULT_OUT_DIR = Path(\"pipeline_examples\"\
      )\\n+\\n+# ---------------------------------------------------------------------------
      #\\n+# Core logic\\n+# ---------------------------------------------------------------------------
      #\\n+\\n+\\n+def _save_example(idx: int, out_base: Path, renderer: SudokuRenderer)
      -> None:\\n+    \"\"\"Generate a single example and save all intermediate artefacts.\"\
      \"\"\\n+    img, gt_grid, corners = renderer.render_sudoku(allow_empty=True)\\\
      n+\\n+    example_dir = out_base / f\"{idx:02d}\"\\n+    example_dir.mkdir(parents=True,
      exist_ok=True)\\n+\\n+    cv2.imwrite(str(example_dir / \"synthetic.png\"),
      img)\\n+    np.save(example_dir / \"gt_grid.npy\", gt_grid)\\n+\\n+    # ──
      Extraction ───────────────────────────────────────────────────────── #\\n+ \
      \   cells, rectified, _ = extract_cells_from_image(img)\\n+\\n+    if rectified
      is not None:\\n+        cv2.imwrite(str(example_dir / \"rectified.png\"), rectified)\\\
      n+\\n+    if cells is not None:\\n+        for i, cell in enumerate(cells):\\\
      n+            r, c = divmod(i, GRID_SIZE)\\n+            cv2.imwrite(str(example_dir
      / f\"cell_{r}{c}.png\"), cell)\\n+\\n+    # Also store the warp corners in case
      somebody wants to visualise them.\\n+    if corners is not None:\\n+       \
      \ np.save(example_dir / \"warp_corners.npy\", corners)\\n+\\n+\\n+# ---------------------------------------------------------------------------
      #\\n+# CLI\\n+# ---------------------------------------------------------------------------
      #\\n+\\n+\\n+def main() -> None:\\n+    try:\\n+        n_examples = int(sys.argv[1])
      if len(sys.argv) > 1 else DEFAULT_N_EXAMPLES\\n+    except ValueError:\\n+ \
      \       print(\"First argument must be an integer (number of examples).\")\\\
      n+        sys.exit(1)\\n+\\n+    out_dir = Path(sys.argv[2]) if len(sys.argv)
      > 2 else DEFAULT_OUT_DIR\\n+    out_dir.mkdir(parents=True, exist_ok=True)\\\
      n+\\n+    print(f\"Generating {n_examples} synthetic Sudoku examples in \\'{out_dir}\\\
      ' …\")\\n+    renderer = SudokuRenderer()\\n+\\n+    n_ok, n_fail = 0, 0\\n+\
      \    idx = 0\\n+    while n_ok < n_examples:\\n+        try:\\n+           \
      \ _save_example(idx, out_dir, renderer)\\n+            n_ok += 1\\n+       \
      \ except Exception as exc:  # pragma: no cover – best‑effort demo script\\n+\
      \            print(f\"[Warning] example\\xa0{idx:02d} failed: {exc}\")\\n+ \
      \           n_fail += 1\\n+        finally:\\n+            idx += 1\\n+\\n+\
      \    print(f\"Done. {n_ok} examples generated; {n_fail} failures skipped.\"
      )\\n+\\n+\\n+if __name__ == \"__main__\":\\n+    main()\\n+\\n*** End Patch\\\
      n```', type='output_text')], role='assistant', status='completed', type='message')],
      parallel_tool_calls=True, temperature=1.0, tool_choice='auto', tools=[], top_p=1.0,
      max_output_tokens=None, previous_response_id=None, reasoning=Reasoning(effort='high',
      generate_summary=None, summary=None), status='completed', text=ResponseTextConfig(format=ResponseFormatText(type='text')),
      truncation='disabled', usage=ResponseUsage(input_tokens=15837, input_tokens_details=InputTokensDetails(cached_tokens=0),
      output_tokens=1686, output_tokens_details=OutputTokensDetails(reasoning_tokens=768),
      total_tokens=17523), user=None, service_tier='default', store=True)"
    metadata:
  - user: |-
      Git apply result:
      No git diff blocks (```diff) found in the last assistant message.
    metadata:
...
