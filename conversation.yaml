local_system:
  attached_files:
    - digit_classifier.py
    - digit_extractor.py
    - sudoku_recogniser.py
    - sudoku_renderer.py
  conversation_file:
  compile_command:
  initial_file_contents:
    digit_classifier.py: |
      # digit_classifier.py
      """
      Convolutional‑NN based digit classifier used by the Sudoku recogniser.

      The module can be executed directly to (re‑)train a model and run a
      quick smoke‑test afterwards.
      """
      from __future__ import annotations

      import gc
      import math
      import os
      import random
      from pathlib import Path
      from typing import Callable, Generator, Tuple

      import cv2
      import keras
      import numpy as np
      import torch
      from keras import callbacks, layers, models

      # --------------------------------------------------------------------------- #
      #  Configure Keras backend – keep this on top to make sure it applies early.  #
      # --------------------------------------------------------------------------- #
      os.environ["KERAS_BACKEND"] = "torch"

      # --------------------------------------------------------------------------- #
      #  Local imports (kept late to avoid circular / backend initialisation woes). #
      # --------------------------------------------------------------------------- #
      from sudoku_renderer import SudokuRenderer, generate_and_save_test_example
      from digit_extractor import (
          GRID_SIZE,
          extract_cells_from_image,
          rectify_grid,
          split_into_cells,
      )
      from sudoku_recogniser import (
          FINAL_CONFIDENCE_THRESHOLD,
          print_sudoku_grid,
      )

      # --------------------------------------------------------------------------- #
      #  Module constants                                                           #
      # --------------------------------------------------------------------------- #
      MODEL_FILENAME = "sudoku_digit_classifier_cnn.keras"
      MODEL_INPUT_SHAPE = (28, 28, 1)

      NUM_CLASSES = 11          # 0‑9 + one “empty” class
      EMPTY_LABEL = 10          # index of the empty class
      TARGET_CELL_CONTENT_SIZE = 24
      TARGET_DIGIT_RATIO = 1.5  # digits : empties within a batch

      EPOCHS = 40
      STEPS_PER_EPOCH = 150
      BATCH_SIZE = 128
      VALIDATION_STEPS = 50

      # --------------------------------------------------------------------------- #
      #  Data generator                                                             #
      # --------------------------------------------------------------------------- #
      DataBatch = Tuple[np.ndarray, np.ndarray]


      def sudoku_data_generator(
          renderer: SudokuRenderer,
          batch_size: int,
          preprocess_func: Callable[[np.ndarray], np.ndarray | None],
          input_size: tuple[int, int, int],
          target_digit_ratio: float = TARGET_DIGIT_RATIO,
      ) -> Generator[DataBatch, None, None]:
          """
          Yields balanced batches of *single‑cell* images and labels generated on‑the‑fly.
          """
          grid_size_sq = GRID_SIZE * GRID_SIZE
          target_digits = int(batch_size * (target_digit_ratio / (1 + target_digit_ratio)))
          target_empty = batch_size - target_digits
          input_h, input_w = input_size[:2]

          while True:
              x_batch, y_batch = [], []
              n_digits = n_empty = 0
              attempts, max_attempts = 0, batch_size * 4

              while len(x_batch) < batch_size and attempts < max_attempts:
                  attempts += 1
                  allow_empty = random.random() < 0.8
                  img, gt_grid, warped_corners = renderer.render_sudoku(allow_empty=allow_empty)
                  if img is None or warped_corners is None:
                      continue

                  try:
                      rectified = rectify_grid(img, warped_corners)
                      if rectified is None:
                          continue

                      cells, _ = split_into_cells(rectified)
                      if len(cells) != grid_size_sq:
                          continue
                  except Exception:
                      continue

                  gt_flat = gt_grid.flatten()
                  cell_indices = list(range(grid_size_sq))
                  random.shuffle(cell_indices)

                  for idx in cell_indices:
                      cell_img = cells[idx]
                      label = gt_flat[idx]
                      is_empty = label == 0
                      model_label = EMPTY_LABEL if is_empty else label

                      if is_empty and n_empty >= target_empty:
                          continue
                      if not is_empty and n_digits >= target_digits:
                          continue

                      processed = preprocess_func(cell_img)
                      if processed is None or processed.shape != (input_h, input_w):
                          continue

                      x_batch.append(processed)
                      y_batch.append(model_label)
                      if is_empty:
                          n_empty += 1
                      else:
                          n_digits += 1

                      if len(x_batch) >= batch_size:
                          break

              if not x_batch:
                  continue  # try again

              x_arr = np.expand_dims(np.asarray(x_batch, dtype="float32"), -1)
              y_arr = np.asarray(y_batch, dtype="int64")
              perm = np.random.permutation(len(y_arr))

              yield x_arr[perm], y_arr[perm]
              del x_batch, y_batch, x_arr, y_arr
              gc.collect()


      # --------------------------------------------------------------------------- #
      #  Epoch‑end callback                                                         #
      # --------------------------------------------------------------------------- #
      class EpochTestCallback(callbacks.Callback):
          """Evaluate the model on a fixed Sudoku after every *frequency* epochs."""

          def __init__(
              self,
              test_img: str | Path,
              gt_grid: np.ndarray,
              classifier: "DigitClassifier",
              frequency: int = 1,
          ) -> None:
              super().__init__()
              self.frequency = max(1, frequency)
              self.gt_grid = gt_grid
              self.classifier = classifier

              cells, *_ = extract_cells_from_image(test_img, debug=False)
              if not cells or len(cells) != GRID_SIZE * GRID_SIZE:
                  self.preprocessed = None
                  print("[Callback] Test image preparation failed – callback disabled.")
                  return

              processed = []
              for cell in cells:
                  proc = classifier._preprocess_cell_for_model(cell)
                  if proc is None:
                      proc = np.zeros(classifier._model_input_size, dtype="float32")
                  processed.append(proc)

              self.preprocessed = np.expand_dims(np.asarray(processed, dtype="float32"), -1)

          # --------------------------------------------------------------------- #
          def on_epoch_end(self, epoch: int, logs: dict | None = None) -> None:
              if self.preprocessed is None or (epoch + 1) % self.frequency:
                  return

              preds = self.model.predict(self.preprocessed, verbose=0)
              idxs = np.argmax(preds, axis=1)
              confs = np.max(preds, axis=1)

              final = []
              for i, c in zip(idxs, confs):
                  digit = 0
                  if i != EMPTY_LABEL and c >= FINAL_CONFIDENCE_THRESHOLD:
                      digit = i
                  final.append(digit)

              pred_grid = np.asarray(final).reshape(GRID_SIZE, GRID_SIZE)
              conf_grid = confs.reshape(GRID_SIZE, GRID_SIZE)

              print(f"\n--- Epoch {epoch + 1} test example ---")
              print("Ground truth:")
              print_sudoku_grid(self.gt_grid, threshold=1.1)

              print("\nPrediction:")
              print_sudoku_grid(pred_grid, conf_grid, threshold=FINAL_CONFIDENCE_THRESHOLD)

              correct = np.sum(pred_grid == self.gt_grid)
              print(f"Accuracy: {correct}/{GRID_SIZE**2} ({correct / GRID_SIZE**2:.4f})")
              print("--- end ---\n")


      # --------------------------------------------------------------------------- #
      #  DigitClassifier                                                             #
      # --------------------------------------------------------------------------- #
      class DigitClassifier:
          """
          Wraps model loading, training and inference.
          """

          def __init__(
              self,
              model_path: str | Path | None = None,
              training_required: bool = False,
          ) -> None:
              self.model_path = Path(model_path or MODEL_FILENAME)
              self.model: keras.Model | None = None
              self._model_input_size = MODEL_INPUT_SHAPE[:2]

              if not training_required and self.model_path.exists():
                  try:
                      self.model = keras.saving.load_model(self.model_path)
                      loaded_shape = self.model.input_shape[1:3]
                      if loaded_shape != self._model_input_size:
                          print(
                              f"[Warning] Model input shape {loaded_shape} "
                              f"!= expected {self._model_input_size}"
                          )
                      print("Model loaded.")
                  except Exception as exc:
                      print(f"[Error] Could not load model: {exc}")

          # --------------------------------------------------------------------- #
          #  Pre‑processing                                                       #
          # --------------------------------------------------------------------- #
          def _preprocess_cell_for_model(
              self, cell: np.ndarray
          ) -> np.ndarray | None:
              """
              Binarise, crop, centre, resize and normalise a single cell image.
              """
              tgt_h, tgt_w = self._model_input_size
              if cell is None or cell.size < 10:
                  return np.zeros((tgt_h, tgt_w), dtype="float32")

              gray = (
                  cv2.cvtColor(cell, cv2.COLOR_BGR2GRAY)
                  if cell.ndim == 3
                  else cell.copy()
              )

              blk = max(3, min(gray.shape) // 4) | 1  # ensure odd
              try:
                  thresh = cv2.adaptiveThreshold(
                      gray,
                      255,
                      cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                      cv2.THRESH_BINARY_INV,
                      blk,
                      7,
                  )
              except cv2.error:
                  return np.zeros((tgt_h, tgt_w), dtype="float32")

              coords = cv2.findNonZero(thresh)
              if coords is None:
                  return np.zeros((tgt_h, tgt_w), dtype="float32")

              x, y, w, h = cv2.boundingRect(coords)
              roi = thresh[y : y + h, x : x + w]
              if roi.size == 0:
                  return np.zeros((tgt_h, tgt_w), dtype="float32")

              scale = min(
                  TARGET_CELL_CONTENT_SIZE / max(1, w),
                  TARGET_CELL_CONTENT_SIZE / max(1, h),
              )
              new_w, new_h = max(1, int(w * scale)), max(1, int(h * scale))
              roi_resized = cv2.resize(roi, (new_w, new_h), interpolation=cv2.INTER_AREA)

              canvas = np.zeros((tgt_h, tgt_w), dtype=np.uint8)
              top = (tgt_h - new_h) // 2
              left = (tgt_w - new_w) // 2
              canvas[top : top + new_h, left : left + new_w] = roi_resized

              return canvas.astype("float32") / 255.0

          # --------------------------------------------------------------------- #
          #  Model architecture                                                   #
          # --------------------------------------------------------------------- #
          def _build_cnn_model(self) -> keras.Model:
              inp = keras.Input(shape=MODEL_INPUT_SHAPE)

              aug = keras.Sequential(
                  [
                      layers.RandomRotation(0.08, fill_mode="constant"),
                      layers.RandomTranslation(0.08, 0.08, fill_mode="constant"),
                      layers.RandomZoom(0.08, 0.08, fill_mode="constant"),
                  ],
                  name="augmentation",
              )
              x = aug(inp)

              # block 1
              for _ in range(2):
                  x = layers.Conv2D(32, (3, 3), padding="same")(x)
                  x = layers.BatchNormalization()(x)
                  x = layers.Activation("relu")(x)
              x = layers.MaxPooling2D((2, 2))(x)
              x = layers.Dropout(0.25)(x)

              # block 2
              for _ in range(2):
                  x = layers.Conv2D(64, (3, 3), padding="same")(x)
                  x = layers.BatchNormalization()(x)
                  x = layers.Activation("relu")(x)
              x = layers.MaxPooling2D((2, 2))(x)
              x = layers.Dropout(0.25)(x)

              x = layers.Flatten()(x)
              x = layers.Dense(128)(x)
              x = layers.BatchNormalization()(x)
              x = layers.Activation("relu")(x)
              x = layers.Dropout(0.5)(x)

              out = layers.Dense(NUM_CLASSES, activation="softmax")(x)

              model = models.Model(inp, out)
              model.compile(
                  optimizer=keras.optimizers.Adam(1e-3),
                  loss="sparse_categorical_crossentropy",
                  metrics=["accuracy"],
              )
              return model

          # --------------------------------------------------------------------- #
          #  Training                                                             #
          # --------------------------------------------------------------------- #
          def train(
              self,
              epochs: int = EPOCHS,
              steps_per_epoch: int = STEPS_PER_EPOCH,
              batch_size: int = BATCH_SIZE,
              validation_steps: int = VALIDATION_STEPS,
          ) -> None:
              print(
                  f"\nTraining parameters: {epochs=}, {steps_per_epoch=}, "
                  f"{batch_size=}, {validation_steps=}"
              )

              try:
                  test_img, test_gt = generate_and_save_test_example()
                  cb_epoch_test = EpochTestCallback(test_img, test_gt, self)
              except Exception as exc:
                  print(f"[Warn] Epoch test example unavailable: {exc}")
                  cb_epoch_test = None

              train_gen = sudoku_data_generator(
                  SudokuRenderer(),
                  batch_size,
                  self._preprocess_cell_for_model,
                  MODEL_INPUT_SHAPE,
              )
              val_gen = sudoku_data_generator(
                  SudokuRenderer(),
                  batch_size,
                  self._preprocess_cell_for_model,
                  MODEL_INPUT_SHAPE,
              )

              if self.model is None:
                  self.model = self._build_cnn_model()

              callbacks_list: list[callbacks.Callback] = [
                  callbacks.EarlyStopping(
                      monitor="val_loss",
                      patience=5,
                      restore_best_weights=True,
                      verbose=1,
                  ),
                  callbacks.ModelCheckpoint(
                      str(self.model_path),
                      monitor="val_loss",
                      save_best_only=True,
                      verbose=1,
                  ),
                  callbacks.ReduceLROnPlateau(
                      monitor="val_loss",
                      factor=0.2,
                      patience=3,
                      min_lr=1e-6,
                      verbose=1,
                  ),
              ]
              if cb_epoch_test and cb_epoch_test.preprocessed is not None:
                  callbacks_list.append(cb_epoch_test)

              self.model.fit(
                  train_gen,
                  epochs=epochs,
                  steps_per_epoch=steps_per_epoch,
                  validation_data=val_gen,
                  validation_steps=validation_steps,
                  callbacks=callbacks_list,
                  verbose=1,
              )

              # final evaluation
              print("\nFinal evaluation:")
              loss, acc = self.model.evaluate(
                  sudoku_data_generator(
                      SudokuRenderer(),
                      batch_size,
                      self._preprocess_cell_for_model,
                      MODEL_INPUT_SHAPE,
                  ),
                  steps=validation_steps,
                  verbose=1,
              )
              print(f"val_loss={loss:.4f}  val_acc={acc:.4f}")

              self.model.save(self.model_path)
              del train_gen, val_gen
              gc.collect()

          # --------------------------------------------------------------------- #
          #  Inference                                                            #
          # --------------------------------------------------------------------- #
          @torch.no_grad()
          def recognise(
              self,
              cell: np.ndarray,
              confidence_threshold: float = 0.7,
          ) -> Tuple[int, float]:
              """
              Return (digit, confidence). 0 means “empty / uncertain”.
              """
              if self.model is None:
                  return 0, 0.0

              proc = self._preprocess_cell_for_model(cell)
              if proc is None or proc.shape != self._model_input_size:
                  return 0, 0.0

              x = np.expand_dims(proc, (0, -1))
              x_tensor = torch.from_numpy(x).float()

              probs = self.model(x_tensor, training=False)[0]
              if isinstance(probs, torch.Tensor):
                  probs = probs.cpu().numpy()

              idx = int(np.argmax(probs))
              conf = float(probs[idx])

              if idx == EMPTY_LABEL or conf < confidence_threshold:
                  return 0, conf
              return idx, conf


      # --------------------------------------------------------------------------- #
      #  CLI / quick test                                                           #
      # --------------------------------------------------------------------------- #
      if __name__ == "__main__":
          FORCE_TRAIN = False
          if FORCE_TRAIN and Path(MODEL_FILENAME).exists():
              Path(MODEL_FILENAME).unlink()

          clf = DigitClassifier(training_required=FORCE_TRAIN)

          if clf.model is None:
              clf.train()

          if clf.model:
              print("\nQuick dummy test:")
              dummy = np.zeros((50, 50), dtype=np.uint8)
              cv2.line(dummy, (25, 10), (25, 40), 255, 3)
              d, c = clf.recognise(dummy, 0.5)
              print(f"Pred (vertical line) -> {d}  conf={c:.3f}")

              empty = np.zeros((50, 50), dtype=np.uint8)
              d, c = clf.recognise(empty, 0.5)
              print(f"Pred (blank)        -> {d}  conf={c:.3f}")
    digit_extractor.py: |
      # digit_extractor.py
      """
      Find a Sudoku grid in an image, rectify it and split it into 81 cell images.
      """
      from __future__ import annotations

      from pathlib import Path
      from typing import List, Tuple

      import cv2
      import numpy as np

      GRID_SIZE = 9
      DEFAULT_RECTIFIED_SIZE = 450


      # --------------------------------------------------------------------------- #
      #  Helpers                                                                    #
      # --------------------------------------------------------------------------- #
      def _order_points(pts: np.ndarray) -> np.ndarray:
          """Return points ordered TL, TR, BR, BL."""
          pts = pts.reshape(4, 2).astype("float32")
          rect = np.zeros((4, 2), dtype="float32")

          s = pts.sum(axis=1)
          rect[0] = pts[np.argmin(s)]
          rect[2] = pts[np.argmax(s)]

          diff = pts[:, 1] - pts[:, 0]
          rect[1] = pts[np.argmin(diff)]
          rect[3] = pts[np.argmax(diff)]
          return rect


      # --------------------------------------------------------------------------- #
      #  Core functionality                                                         #
      # --------------------------------------------------------------------------- #
      def find_sudoku_grid_contour(
          img: np.ndarray, *, debug_dir: Path | None = None
      ) -> np.ndarray:
          """Return a four‑point contour of the outer Sudoku boundary."""
          gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) if img.ndim == 3 else img.copy()

          if debug_dir:
              debug_dir.mkdir(parents=True, exist_ok=True)

          blur = cv2.GaussianBlur(gray, (7, 7), 0)
          thresh = cv2.adaptiveThreshold(
              blur,
              255,
              cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
              cv2.THRESH_BINARY_INV,
              15,
              4,
          )
          closed = cv2.morphologyEx(
              thresh,
              cv2.MORPH_CLOSE,
              cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3)),
              iterations=2,
          )

          contours, _ = cv2.findContours(
              closed, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE
          )
          contours = sorted(contours, key=cv2.contourArea, reverse=True)

          min_area = gray.size * 0.1
          for cnt in contours:
              if cv2.contourArea(cnt) < min_area:
                  break
              peri = cv2.arcLength(cnt, True)
              approx = cv2.approxPolyDP(cnt, 0.02 * peri, True)
              if len(approx) == 4 and cv2.isContourConvex(approx):
                  x, y, w, h = cv2.boundingRect(approx)
                  if 0.8 < w / h < 1.2:
                      return approx.reshape(4, 2).astype("float32")

          raise ValueError("Sudoku grid not found.")


      def rectify_grid(
          img: np.ndarray, contour: np.ndarray, *, size: int = DEFAULT_RECTIFIED_SIZE
      ) -> np.ndarray | None:
          """Perspective‑correct the Sudoku grid."""
          try:
              src = _order_points(contour)
              dst = np.array(
                  [[0, 0], [size - 1, 0], [size - 1, size - 1], [0, size - 1]],
                  dtype="float32",
              )
              m = cv2.getPerspectiveTransform(src, dst)
              return cv2.warpPerspective(img, m, (size, size))
          except cv2.error:
              return None


      def split_into_cells(
          rectified: np.ndarray,
      ) -> Tuple[List[np.ndarray], np.ndarray]:
          """Return list with 81 cells (cropped)."""
          h, w = rectified.shape[:2]
          if h != w:
              size = max(h, w)
              rectified = cv2.resize(rectified, (size, size))
              h = w = size

          cell_size = h // GRID_SIZE
          margin = int(cell_size * 0.04)
          cells: list[np.ndarray] = []

          for r in range(GRID_SIZE):
              for c in range(GRID_SIZE):
                  y0 = r * cell_size + margin
                  x0 = c * cell_size + margin
                  y1 = (r + 1) * cell_size - margin
                  x1 = (c + 1) * cell_size - margin
                  if y0 >= y1 or x0 >= x1:
                      cell = np.zeros((cell_size, cell_size), rectified.dtype)
                  else:
                      cell = rectified[y0:y1, x0:x1]
                  cells.append(cell)

          return cells, rectified


      def extract_cells_from_image(
          img_or_path, *, size: int = DEFAULT_RECTIFIED_SIZE, debug: bool = False
      ):
          """High‑level convenience function."""
          if isinstance(img_or_path, (str, Path)):
              img = cv2.imread(str(img_or_path))
              if img is None:
                  return None, None, None
          elif isinstance(img_or_path, np.ndarray):
              img = img_or_path.copy()
          else:
              return None, None, None

          try:
              contour = find_sudoku_grid_contour(img, debug_dir=Path(f"debug_{os.getpid()}") if debug else None)
              rectified = rectify_grid(img, contour, size=size)
              if rectified is None:
                  return None, None, None
              cells, rectified = split_into_cells(rectified)
              return cells, rectified, contour
          except Exception as exc:
              print(f"[Extractor] {exc}")
              return None, None, None
    sudoku_recogniser.py: |
      # sudoku_recogniser.py
      """
      Command‑line utility: detect a Sudoku grid in an image and recognise its digits.
      """
      from __future__ import annotations

      import sys
      import time
      from pathlib import Path
      from typing import Tuple

      import cv2
      import numpy as np

      from digit_classifier import (
          EMPTY_LABEL,
          MODEL_FILENAME,
          DigitClassifier,
      )
      from digit_extractor import GRID_SIZE, extract_cells_from_image

      FINAL_CONFIDENCE_THRESHOLD = 0.80


      # --------------------------------------------------------------------------- #
      #  Pretty printing                                                            #
      # --------------------------------------------------------------------------- #
      def print_sudoku_grid(
          grid: np.ndarray,
          conf: np.ndarray | None = None,
          threshold: float = FINAL_CONFIDENCE_THRESHOLD,
      ) -> None:
          """Nicely print a 9×9 Sudoku grid."""
          grid = np.asarray(grid)
          if grid.shape != (GRID_SIZE, GRID_SIZE):
              print("[print_sudoku_grid] invalid shape")
              return

          for r in range(GRID_SIZE):
              if r and r % 3 == 0:
                  print("|-------+-------+-------|")

              line = []
              for c in range(GRID_SIZE):
                  d = grid[r, c]
                  if d == 0:
                      token = "."
                  else:
                      token = str(d)
                      if conf is not None and conf[r, c] < threshold:
                          token = "?"
                  line.append(token)

                  if (c + 1) % 3 == 0 and c != GRID_SIZE - 1:
                      line.append("|")
              print(" ".join(line))
          print()


      # --------------------------------------------------------------------------- #
      #  Overlay helper                                                             #
      # --------------------------------------------------------------------------- #
      def display_results_on_image(
          rectified: np.ndarray, grid: np.ndarray
      ) -> np.ndarray | None:
          """Draw recognised digits onto the rectified grid image."""
          if rectified is None:
              return None

          img = (
              cv2.cvtColor(rectified, cv2.COLOR_GRAY2BGR)
              if rectified.ndim == 2
              else rectified.copy()
          )
          h, w = img.shape[:2]
          cell_h, cell_w = h // GRID_SIZE, w // GRID_SIZE

          for r in range(GRID_SIZE):
              for c in range(GRID_SIZE):
                  d = grid[r, c]
                  if d == 0:
                      continue
                  text = str(d)
                  (tw, th), bl = cv2.getTextSize(text, cv2.FONT_HERSHEY_SIMPLEX, 1, 2)
                  x = c * cell_w + (cell_w - tw) // 2
                  y = r * cell_h + (cell_h + th) // 2
                  cv2.putText(
                      img,
                      text,
                      (x, y),
                      cv2.FONT_HERSHEY_SIMPLEX,
                      1,
                      (0, 255, 0),
                      2,
                      cv2.LINE_AA,
                  )
          return img


      # --------------------------------------------------------------------------- #
      #  Recognition pipeline                                                       #
      # --------------------------------------------------------------------------- #
      def recognise_sudoku(
          img_path: Path,
          classifier: DigitClassifier,
      ) -> Tuple[np.ndarray, np.ndarray, np.ndarray | None]:
          """Extract cells and run the classifier."""
          print(f"Processing {img_path} ...")
          start = time.time()
          cells, rectified, _ = extract_cells_from_image(img_path)
          if cells is None:
              raise RuntimeError("Extraction failed.")

          pred = np.zeros((GRID_SIZE, GRID_SIZE), int)
          conf = np.zeros_like(pred, float)

          for i, cell in enumerate(cells):
              r, c = divmod(i, GRID_SIZE)
              d, cf = classifier.recognise(cell, confidence_threshold=0.1)
              conf[r, c] = cf
              if d and cf >= FINAL_CONFIDENCE_THRESHOLD:
                  pred[r, c] = d

          print(f"Done in {time.time() - start:.2f}s")
          return pred, conf, rectified


      # --------------------------------------------------------------------------- #
      #  Entry‑point                                                                #
      # --------------------------------------------------------------------------- #
      def main() -> None:
          if len(sys.argv) < 2:
              print("Usage: sudoku_recogniser.py <image>")
              sys.exit(0)

          img_path = Path(sys.argv[1])
          if not img_path.exists():
              print("Image not found.")
              sys.exit(1)

          clf = DigitClassifier(model_path=MODEL_FILENAME)
          if clf.model is None:
              print("Model missing – training required.")
              clf.train()

          grid, conf, rectified = recognise_sudoku(img_path, clf)
          print_sudoku_grid(grid, conf)

          res = display_results_on_image(rectified, grid)
          if res is not None:
              cv2.imshow("Result", res)
              cv2.waitKey(0)
              cv2.destroyAllWindows()


      if __name__ == "__main__":
          main()
    sudoku_renderer.py: |
      # sudoku_renderer.py
      """
      Synthetic Sudoku image generator used for on‑the‑fly training data creation.
      """
      from __future__ import annotations

      import random
      from pathlib import Path
      from typing import Tuple

      import cv2
      import numpy as np
      import keras

      GRID_SIZE = 9
      BASE_IMAGE_SIZE = 1000
      CELL_SIZE = BASE_IMAGE_SIZE // GRID_SIZE
      MNIST_SIZE = 28


      def _order_points(pts: np.ndarray) -> np.ndarray:
          pts = pts.reshape(4, 2).astype("float32")
          rect = np.zeros((4, 2), dtype="float32")
          s = pts.sum(axis=1)
          rect[0] = pts[np.argmin(s)]
          rect[2] = pts[np.argmax(s)]
          diff = pts[:, 1] - pts[:, 0]
          rect[1] = pts[np.argmin(diff)]
          rect[3] = pts[np.argmax(diff)]
          return rect


      def _load_mnist_digits() -> dict[int, list[np.ndarray]]:
          """Download (once) and prepare MNIST for rendering digits."""
          (x_train, y_train), (x_test, y_test) = keras.datasets.mnist.load_data()
          imgs = np.concatenate([x_train, x_test])
          labels = np.concatenate([y_train, y_test])

          buckets: dict[int, list[np.ndarray]] = {i: [] for i in range(10)}
          for img, lbl in zip(imgs, labels):
              inv = cv2.bitwise_not(img)
              padded = cv2.copyMakeBorder(inv, 4, 4, 4, 4, cv2.BORDER_CONSTANT, value=255)
              buckets[int(lbl)].append(padded)
          return buckets


      class SudokuRenderer:
          """Render a random (optionally given) Sudoku grid to an image."""

          def __init__(self) -> None:
              self.mnist: dict[int, list[np.ndarray]] | None = None

          # --------------------------------------------------------------------- #
          #  Internals                                                            #
          # --------------------------------------------------------------------- #
          def _digit_source(self, digit: int) -> Tuple[np.ndarray | None, str]:
              srcs = []
              if self.mnist is None:
                  self.mnist = _load_mnist_digits()
              if self.mnist[digit]:
                  srcs.append("mnist")
              srcs.append("font")
              choice = random.choice(srcs)

              if choice == "mnist":
                  img = random.choice(self.mnist[digit])
                  if img.ndim == 2:
                      img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
                  return img, "mnist"
              return None, "font"

          # --------------------------------------------------------------------- #
          #  Public                                                               #
          # --------------------------------------------------------------------- #
          def render_sudoku(
              self,
              grid_spec: list[list[int | None]] | np.ndarray | None = None,
              *,
              allow_empty: bool = True,
          ):
              """Return (image, gt_grid, warped_corners)."""
              # ground truth ---------------------------------------------------- #
              if grid_spec is None:
                  gt = np.zeros((GRID_SIZE, GRID_SIZE), int)
                  for r in range(GRID_SIZE):
                      for c in range(GRID_SIZE):
                          if allow_empty and random.random() < 0.4:
                              continue
                          gt[r, c] = random.randint(1, 9)
              else:
                  gt = np.asarray([[d or 0 for d in row] for row in grid_spec], int)

              # canvas ----------------------------------------------------------- #
              bg_color = tuple(random.randint(200, 240) for _ in range(3))
              img = np.full((BASE_IMAGE_SIZE, BASE_IMAGE_SIZE, 3), bg_color, np.uint8)

              # grid lines ------------------------------------------------------- #
              for i in range(GRID_SIZE + 1):
                  major = i % 3 == 0
                  thick = random.randint(3 if major else 1, 5 if major else 3)
                  cv2.line(img, (0, i * CELL_SIZE), (BASE_IMAGE_SIZE, i * CELL_SIZE), (0, 0, 0), thick)
                  cv2.line(img, (i * CELL_SIZE, 0), (i * CELL_SIZE, BASE_IMAGE_SIZE), (0, 0, 0), thick)

              # digits ----------------------------------------------------------- #
              for r in range(GRID_SIZE):
                  for c in range(GRID_SIZE):
                      d = gt[r, c]
                      if d == 0:
                          continue

                      src_img, src_type = self._digit_source(d)
                      scale = random.uniform(0.5, 0.8)
                      tgt_h = tgt_w = int(CELL_SIZE * scale)
                      center_x = c * CELL_SIZE + CELL_SIZE // 2
                      center_y = r * CELL_SIZE + CELL_SIZE // 2
                      offset_x = int(random.uniform(-0.1, 0.1) * CELL_SIZE)
                      offset_y = int(random.uniform(-0.1, 0.1) * CELL_SIZE)
                      cx, cy = center_x + offset_x, center_y + offset_y

                      if src_type == "mnist":
                          rot = random.uniform(-10, 10)
                          M = cv2.getRotationMatrix2D((tgt_w / 2, tgt_h / 2), rot, 1)
                          digit = cv2.resize(src_img, (tgt_w, tgt_h))
                          digit = cv2.warpAffine(
                              digit,
                              M,
                              (tgt_w, tgt_h),
                              borderMode=cv2.BORDER_CONSTANT,
                              borderValue=(255, 255, 255),
                          )
                          mask = cv2.cvtColor(digit, cv2.COLOR_BGR2GRAY)
                          _, mask = cv2.threshold(mask, 250, 255, cv2.THRESH_BINARY_INV)

                          x0 = max(0, cx - tgt_w // 2)
                          y0 = max(0, cy - tgt_h // 2)
                          roi = img[y0 : y0 + tgt_h, x0 : x0 + tgt_w]
                          mask_inv = cv2.bitwise_not(mask[: roi.shape[0], : roi.shape[1]])
                          bg = cv2.bitwise_and(roi, roi, mask=mask_inv)
                          fg = cv2.bitwise_and(digit, digit, mask=mask[: roi.shape[0], : roi.shape[1]])
                          img[y0 : y0 + roi.shape[0], x0 : x0 + roi.shape[1]] = cv2.add(bg, fg)
                      else:  # font
                          font = cv2.FONT_HERSHEY_SIMPLEX
                          thickness = random.randint(1, 3)
                          font_scale = cv2.getFontScaleFromHeight(font, tgt_h, thickness) * 0.8
                          tw, th = cv2.getTextSize(str(d), font, font_scale, thickness)[0]
                          x = cx - tw // 2
                          y = cy + th // 2
                          cv2.putText(
                              img,
                              str(d),
                              (x, y),
                              font,
                              font_scale,
                              (0, 0, 0),
                              thickness,
                              cv2.LINE_AA,
                          )

              # noise ------------------------------------------------------------ #
              noise = np.random.normal(0, random.uniform(5, 20), img.shape).astype(np.float32)
              img = np.clip(img.astype(np.float32) + noise, 0, 255).astype(np.uint8)

              # perspective ------------------------------------------------------ #
              h, w = img.shape[:2]
              orig = np.array([[0, 0], [w - 1, 0], [w - 1, h - 1], [0, h - 1]], "float32")
              shift = random.uniform(0.05, 0.2)
              max_x, max_y = w * shift, h * shift
              dst = np.array(
                  [
                      [random.uniform(0, max_x), random.uniform(0, max_y)],
                      [w - 1 - random.uniform(0, max_x), random.uniform(0, max_y)],
                      [
                          w - 1 - random.uniform(-max_x * 0.2, max_x),
                          h - 1 - random.uniform(0, max_y * 0.5),
                      ],
                      [random.uniform(-max_x * 0.2, max_x), h - 1 - random.uniform(0, max_y * 0.5)],
                  ],
                  "float32",
              )
              M = cv2.getPerspectiveTransform(orig, dst)
              out_w, out_h = int(np.ceil(dst[:, 0].max())), int(np.ceil(dst[:, 1].max()))
              warped = cv2.warpPerspective(img, M, (out_w, out_h), borderMode=cv2.BORDER_REPLICATE)
              return warped, gt, dst


      # --------------------------------------------------------------------------- #
      #  Deterministic test example                                                 #
      # --------------------------------------------------------------------------- #
      def generate_and_save_test_example(
          prefix: str = "epoch_test_sudoku", *, force: bool = False
      ):
          img_path = Path(f"{prefix}.png")
          gt_path = Path(f"{prefix}_gt.npy")

          if not force and img_path.exists() and gt_path.exists():
              return str(img_path), np.load(gt_path)

          renderer = SudokuRenderer()
          img, gt, _ = renderer.render_sudoku(
              grid_spec=[
                  [None, None, 3, None, None, 6, None, 8, None],
                  [8, None, 1, None, 3, None, 5, None, 4],
                  [None, 4, None, 8, None, 7, None, 1, None],
                  [1, None, None, 4, None, 5, None, None, 9],
                  [None, 7, None, None, 2, None, None, 4, None],
                  [5, None, None, 7, None, 1, None, None, 3],
                  [None, 8, None, 5, None, 3, None, 9, None],
                  [7, None, 4, None, 9, None, 1, None, 8],
                  [None, 1, None, 6, None, None, 4, None, None],
              ]
          )
          cv2.imwrite(str(img_path), img)
          np.save(gt_path, gt)
          return str(img_path), gt
  prev_file_contents:
    digit_classifier.py: |
      # digit_classifier.py
      """
      Convolutional‑NN based digit classifier used by the Sudoku recogniser.

      The module can be executed directly to (re‑)train a model and run a
      quick smoke‑test afterwards.
      """
      from __future__ import annotations

      import gc
      import math
      import os
      import random
      from pathlib import Path
      from typing import Callable, Generator, Tuple

      import cv2
      import keras
      import numpy as np
      import torch
      from keras import callbacks, layers, models

      # --------------------------------------------------------------------------- #
      #  Configure Keras backend – keep this on top to make sure it applies early.  #
      # --------------------------------------------------------------------------- #
      os.environ["KERAS_BACKEND"] = "torch"

      # --------------------------------------------------------------------------- #
      #  Local imports (kept late to avoid circular / backend initialisation woes). #
      # --------------------------------------------------------------------------- #
      from sudoku_renderer import SudokuRenderer, generate_and_save_test_example
      from digit_extractor import (
          GRID_SIZE,
          extract_cells_from_image,
          rectify_grid,
          split_into_cells,
      )
      from sudoku_recogniser import (
          FINAL_CONFIDENCE_THRESHOLD,
          print_sudoku_grid,
      )

      # --------------------------------------------------------------------------- #
      #  Module constants                                                           #
      # --------------------------------------------------------------------------- #
      MODEL_FILENAME = "sudoku_digit_classifier_cnn.keras"
      MODEL_INPUT_SHAPE = (28, 28, 1)

      NUM_CLASSES = 11          # 0‑9 + one “empty” class
      EMPTY_LABEL = 10          # index of the empty class
      TARGET_CELL_CONTENT_SIZE = 24
      TARGET_DIGIT_RATIO = 1.5  # digits : empties within a batch

      EPOCHS = 40
      STEPS_PER_EPOCH = 150
      BATCH_SIZE = 128
      VALIDATION_STEPS = 50

      # --------------------------------------------------------------------------- #
      #  Data generator                                                             #
      # --------------------------------------------------------------------------- #
      DataBatch = Tuple[np.ndarray, np.ndarray]


      def sudoku_data_generator(
          renderer: SudokuRenderer,
          batch_size: int,
          preprocess_func: Callable[[np.ndarray], np.ndarray | None],
          input_size: tuple[int, int, int],
          target_digit_ratio: float = TARGET_DIGIT_RATIO,
      ) -> Generator[DataBatch, None, None]:
          """
          Yields balanced batches of *single‑cell* images and labels generated on‑the‑fly.
          """
          grid_size_sq = GRID_SIZE * GRID_SIZE
          target_digits = int(batch_size * (target_digit_ratio / (1 + target_digit_ratio)))
          target_empty = batch_size - target_digits
          input_h, input_w = input_size[:2]

          while True:
              x_batch, y_batch = [], []
              n_digits = n_empty = 0
              attempts, max_attempts = 0, batch_size * 4

              while len(x_batch) < batch_size and attempts < max_attempts:
                  attempts += 1
                  allow_empty = random.random() < 0.8
                  img, gt_grid, warped_corners = renderer.render_sudoku(allow_empty=allow_empty)
                  if img is None or warped_corners is None:
                      continue

                  try:
                      rectified = rectify_grid(img, warped_corners)
                      if rectified is None:
                          continue

                      cells, _ = split_into_cells(rectified)
                      if len(cells) != grid_size_sq:
                          continue
                  except Exception:
                      continue

                  gt_flat = gt_grid.flatten()
                  cell_indices = list(range(grid_size_sq))
                  random.shuffle(cell_indices)

                  for idx in cell_indices:
                      cell_img = cells[idx]
                      label = gt_flat[idx]
                      is_empty = label == 0
                      model_label = EMPTY_LABEL if is_empty else label

                      if is_empty and n_empty >= target_empty:
                          continue
                      if not is_empty and n_digits >= target_digits:
                          continue

                      processed = preprocess_func(cell_img)
                      if processed is None or processed.shape != (input_h, input_w):
                          continue

                      x_batch.append(processed)
                      y_batch.append(model_label)
                      if is_empty:
                          n_empty += 1
                      else:
                          n_digits += 1

                      if len(x_batch) >= batch_size:
                          break

              if not x_batch:
                  continue  # try again

              x_arr = np.expand_dims(np.asarray(x_batch, dtype="float32"), -1)
              y_arr = np.asarray(y_batch, dtype="int64")
              perm = np.random.permutation(len(y_arr))

              yield x_arr[perm], y_arr[perm]
              del x_batch, y_batch, x_arr, y_arr
              gc.collect()


      # --------------------------------------------------------------------------- #
      #  Epoch‑end callback                                                         #
      # --------------------------------------------------------------------------- #
      class EpochTestCallback(callbacks.Callback):
          """Evaluate the model on a fixed Sudoku after every *frequency* epochs."""

          def __init__(
              self,
              test_img: str | Path,
              gt_grid: np.ndarray,
              classifier: "DigitClassifier",
              frequency: int = 1,
          ) -> None:
              super().__init__()
              self.frequency = max(1, frequency)
              self.gt_grid = gt_grid
              self.classifier = classifier

              cells, *_ = extract_cells_from_image(test_img, debug=False)
              if not cells or len(cells) != GRID_SIZE * GRID_SIZE:
                  self.preprocessed = None
                  print("[Callback] Test image preparation failed – callback disabled.")
                  return

              processed = []
              for cell in cells:
                  proc = classifier._preprocess_cell_for_model(cell)
                  if proc is None:
                      proc = np.zeros(classifier._model_input_size, dtype="float32")
                  processed.append(proc)

              self.preprocessed = np.expand_dims(np.asarray(processed, dtype="float32"), -1)

          # --------------------------------------------------------------------- #
          def on_epoch_end(self, epoch: int, logs: dict | None = None) -> None:
              if self.preprocessed is None or (epoch + 1) % self.frequency:
                  return

              preds = self.model.predict(self.preprocessed, verbose=0)
              idxs = np.argmax(preds, axis=1)
              confs = np.max(preds, axis=1)

              final = []
              for i, c in zip(idxs, confs):
                  digit = 0
                  if i != EMPTY_LABEL and c >= FINAL_CONFIDENCE_THRESHOLD:
                      digit = i
                  final.append(digit)

              pred_grid = np.asarray(final).reshape(GRID_SIZE, GRID_SIZE)
              conf_grid = confs.reshape(GRID_SIZE, GRID_SIZE)

              print(f"\n--- Epoch {epoch + 1} test example ---")
              print("Ground truth:")
              print_sudoku_grid(self.gt_grid, threshold=1.1)

              print("\nPrediction:")
              print_sudoku_grid(pred_grid, conf_grid, threshold=FINAL_CONFIDENCE_THRESHOLD)

              correct = np.sum(pred_grid == self.gt_grid)
              print(f"Accuracy: {correct}/{GRID_SIZE**2} ({correct / GRID_SIZE**2:.4f})")
              print("--- end ---\n")


      # --------------------------------------------------------------------------- #
      #  DigitClassifier                                                             #
      # --------------------------------------------------------------------------- #
      class DigitClassifier:
          """
          Wraps model loading, training and inference.
          """

          def __init__(
              self,
              model_path: str | Path | None = None,
              training_required: bool = False,
          ) -> None:
              self.model_path = Path(model_path or MODEL_FILENAME)
              self.model: keras.Model | None = None
              self._model_input_size = MODEL_INPUT_SHAPE[:2]

              if not training_required and self.model_path.exists():
                  try:
                      self.model = keras.saving.load_model(self.model_path)
                      loaded_shape = self.model.input_shape[1:3]
                      if loaded_shape != self._model_input_size:
                          print(
                              f"[Warning] Model input shape {loaded_shape} "
                              f"!= expected {self._model_input_size}"
                          )
                      print("Model loaded.")
                  except Exception as exc:
                      print(f"[Error] Could not load model: {exc}")

          # --------------------------------------------------------------------- #
          #  Pre‑processing                                                       #
          # --------------------------------------------------------------------- #
          def _preprocess_cell_for_model(
              self, cell: np.ndarray
          ) -> np.ndarray | None:
              """
              Binarise, crop, centre, resize and normalise a single cell image.
              """
              tgt_h, tgt_w = self._model_input_size
              if cell is None or cell.size < 10:
                  return np.zeros((tgt_h, tgt_w), dtype="float32")

              gray = (
                  cv2.cvtColor(cell, cv2.COLOR_BGR2GRAY)
                  if cell.ndim == 3
                  else cell.copy()
              )

              blk = max(3, min(gray.shape) // 4) | 1  # ensure odd
              try:
                  thresh = cv2.adaptiveThreshold(
                      gray,
                      255,
                      cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                      cv2.THRESH_BINARY_INV,
                      blk,
                      7,
                  )
              except cv2.error:
                  return np.zeros((tgt_h, tgt_w), dtype="float32")

              coords = cv2.findNonZero(thresh)
              if coords is None:
                  return np.zeros((tgt_h, tgt_w), dtype="float32")

              x, y, w, h = cv2.boundingRect(coords)
              roi = thresh[y : y + h, x : x + w]
              if roi.size == 0:
                  return np.zeros((tgt_h, tgt_w), dtype="float32")

              scale = min(
                  TARGET_CELL_CONTENT_SIZE / max(1, w),
                  TARGET_CELL_CONTENT_SIZE / max(1, h),
              )
              new_w, new_h = max(1, int(w * scale)), max(1, int(h * scale))
              roi_resized = cv2.resize(roi, (new_w, new_h), interpolation=cv2.INTER_AREA)

              canvas = np.zeros((tgt_h, tgt_w), dtype=np.uint8)
              top = (tgt_h - new_h) // 2
              left = (tgt_w - new_w) // 2
              canvas[top : top + new_h, left : left + new_w] = roi_resized

              return canvas.astype("float32") / 255.0

          # --------------------------------------------------------------------- #
          #  Model architecture                                                   #
          # --------------------------------------------------------------------- #
          def _build_cnn_model(self) -> keras.Model:
              inp = keras.Input(shape=MODEL_INPUT_SHAPE)

              aug = keras.Sequential(
                  [
                      layers.RandomRotation(0.08, fill_mode="constant"),
                      layers.RandomTranslation(0.08, 0.08, fill_mode="constant"),
                      layers.RandomZoom(0.08, 0.08, fill_mode="constant"),
                  ],
                  name="augmentation",
              )
              x = aug(inp)

              # block 1
              for _ in range(2):
                  x = layers.Conv2D(32, (3, 3), padding="same")(x)
                  x = layers.BatchNormalization()(x)
                  x = layers.Activation("relu")(x)
              x = layers.MaxPooling2D((2, 2))(x)
              x = layers.Dropout(0.25)(x)

              # block 2
              for _ in range(2):
                  x = layers.Conv2D(64, (3, 3), padding="same")(x)
                  x = layers.BatchNormalization()(x)
                  x = layers.Activation("relu")(x)
              x = layers.MaxPooling2D((2, 2))(x)
              x = layers.Dropout(0.25)(x)

              x = layers.Flatten()(x)
              x = layers.Dense(128)(x)
              x = layers.BatchNormalization()(x)
              x = layers.Activation("relu")(x)
              x = layers.Dropout(0.5)(x)

              out = layers.Dense(NUM_CLASSES, activation="softmax")(x)

              model = models.Model(inp, out)
              model.compile(
                  optimizer=keras.optimizers.Adam(1e-3),
                  loss="sparse_categorical_crossentropy",
                  metrics=["accuracy"],
              )
              return model

          # --------------------------------------------------------------------- #
          #  Training                                                             #
          # --------------------------------------------------------------------- #
          def train(
              self,
              epochs: int = EPOCHS,
              steps_per_epoch: int = STEPS_PER_EPOCH,
              batch_size: int = BATCH_SIZE,
              validation_steps: int = VALIDATION_STEPS,
          ) -> None:
              print(
                  f"\nTraining parameters: {epochs=}, {steps_per_epoch=}, "
                  f"{batch_size=}, {validation_steps=}"
              )

              try:
                  test_img, test_gt = generate_and_save_test_example()
                  cb_epoch_test = EpochTestCallback(test_img, test_gt, self)
              except Exception as exc:
                  print(f"[Warn] Epoch test example unavailable: {exc}")
                  cb_epoch_test = None

              train_gen = sudoku_data_generator(
                  SudokuRenderer(),
                  batch_size,
                  self._preprocess_cell_for_model,
                  MODEL_INPUT_SHAPE,
              )
              val_gen = sudoku_data_generator(
                  SudokuRenderer(),
                  batch_size,
                  self._preprocess_cell_for_model,
                  MODEL_INPUT_SHAPE,
              )

              if self.model is None:
                  self.model = self._build_cnn_model()

              callbacks_list: list[callbacks.Callback] = [
                  callbacks.EarlyStopping(
                      monitor="val_loss",
                      patience=5,
                      restore_best_weights=True,
                      verbose=1,
                  ),
                  callbacks.ModelCheckpoint(
                      str(self.model_path),
                      monitor="val_loss",
                      save_best_only=True,
                      verbose=1,
                  ),
                  callbacks.ReduceLROnPlateau(
                      monitor="val_loss",
                      factor=0.2,
                      patience=3,
                      min_lr=1e-6,
                      verbose=1,
                  ),
              ]
              if cb_epoch_test and cb_epoch_test.preprocessed is not None:
                  callbacks_list.append(cb_epoch_test)

              self.model.fit(
                  train_gen,
                  epochs=epochs,
                  steps_per_epoch=steps_per_epoch,
                  validation_data=val_gen,
                  validation_steps=validation_steps,
                  callbacks=callbacks_list,
                  verbose=1,
              )

              # final evaluation
              print("\nFinal evaluation:")
              loss, acc = self.model.evaluate(
                  sudoku_data_generator(
                      SudokuRenderer(),
                      batch_size,
                      self._preprocess_cell_for_model,
                      MODEL_INPUT_SHAPE,
                  ),
                  steps=validation_steps,
                  verbose=1,
              )
              print(f"val_loss={loss:.4f}  val_acc={acc:.4f}")

              self.model.save(self.model_path)
              del train_gen, val_gen
              gc.collect()

          # --------------------------------------------------------------------- #
          #  Inference                                                            #
          # --------------------------------------------------------------------- #
          @torch.no_grad()
          def recognise(
              self,
              cell: np.ndarray,
              confidence_threshold: float = 0.7,
          ) -> Tuple[int, float]:
              """
              Return (digit, confidence). 0 means “empty / uncertain”.
              """
              if self.model is None:
                  return 0, 0.0

              proc = self._preprocess_cell_for_model(cell)
              if proc is None or proc.shape != self._model_input_size:
                  return 0, 0.0

              x = np.expand_dims(proc, (0, -1))
              x_tensor = torch.from_numpy(x).float()

              probs = self.model(x_tensor, training=False)[0]
              if isinstance(probs, torch.Tensor):
                  probs = probs.cpu().numpy()

              idx = int(np.argmax(probs))
              conf = float(probs[idx])

              if idx == EMPTY_LABEL or conf < confidence_threshold:
                  return 0, conf
              return idx, conf


      # --------------------------------------------------------------------------- #
      #  CLI / quick test                                                           #
      # --------------------------------------------------------------------------- #
      if __name__ == "__main__":
          FORCE_TRAIN = False
          if FORCE_TRAIN and Path(MODEL_FILENAME).exists():
              Path(MODEL_FILENAME).unlink()

          clf = DigitClassifier(training_required=FORCE_TRAIN)

          if clf.model is None:
              clf.train()

          if clf.model:
              print("\nQuick dummy test:")
              dummy = np.zeros((50, 50), dtype=np.uint8)
              cv2.line(dummy, (25, 10), (25, 40), 255, 3)
              d, c = clf.recognise(dummy, 0.5)
              print(f"Pred (vertical line) -> {d}  conf={c:.3f}")

              empty = np.zeros((50, 50), dtype=np.uint8)
              d, c = clf.recognise(empty, 0.5)
              print(f"Pred (blank)        -> {d}  conf={c:.3f}")
    digit_extractor.py: |
      # digit_extractor.py
      """
      Find a Sudoku grid in an image, rectify it and split it into 81 cell images.
      """
      from __future__ import annotations

      from pathlib import Path
      from typing import List, Tuple

      import cv2
      import numpy as np

      GRID_SIZE = 9
      DEFAULT_RECTIFIED_SIZE = 450


      # --------------------------------------------------------------------------- #
      #  Helpers                                                                    #
      # --------------------------------------------------------------------------- #
      def _order_points(pts: np.ndarray) -> np.ndarray:
          """Return points ordered TL, TR, BR, BL."""
          pts = pts.reshape(4, 2).astype("float32")
          rect = np.zeros((4, 2), dtype="float32")

          s = pts.sum(axis=1)
          rect[0] = pts[np.argmin(s)]
          rect[2] = pts[np.argmax(s)]

          diff = pts[:, 1] - pts[:, 0]
          rect[1] = pts[np.argmin(diff)]
          rect[3] = pts[np.argmax(diff)]
          return rect


      # --------------------------------------------------------------------------- #
      #  Core functionality                                                         #
      # --------------------------------------------------------------------------- #
      def find_sudoku_grid_contour(
          img: np.ndarray, *, debug_dir: Path | None = None
      ) -> np.ndarray:
          """Return a four‑point contour of the outer Sudoku boundary."""
          gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) if img.ndim == 3 else img.copy()

          if debug_dir:
              debug_dir.mkdir(parents=True, exist_ok=True)

          blur = cv2.GaussianBlur(gray, (7, 7), 0)
          thresh = cv2.adaptiveThreshold(
              blur,
              255,
              cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
              cv2.THRESH_BINARY_INV,
              15,
              4,
          )
          closed = cv2.morphologyEx(
              thresh,
              cv2.MORPH_CLOSE,
              cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3)),
              iterations=2,
          )

          contours, _ = cv2.findContours(
              closed, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE
          )
          contours = sorted(contours, key=cv2.contourArea, reverse=True)

          min_area = gray.size * 0.1
          for cnt in contours:
              if cv2.contourArea(cnt) < min_area:
                  break
              peri = cv2.arcLength(cnt, True)
              approx = cv2.approxPolyDP(cnt, 0.02 * peri, True)
              if len(approx) == 4 and cv2.isContourConvex(approx):
                  x, y, w, h = cv2.boundingRect(approx)
                  if 0.8 < w / h < 1.2:
                      return approx.reshape(4, 2).astype("float32")

          raise ValueError("Sudoku grid not found.")


      def rectify_grid(
          img: np.ndarray, contour: np.ndarray, *, size: int = DEFAULT_RECTIFIED_SIZE
      ) -> np.ndarray | None:
          """Perspective‑correct the Sudoku grid."""
          try:
              src = _order_points(contour)
              dst = np.array(
                  [[0, 0], [size - 1, 0], [size - 1, size - 1], [0, size - 1]],
                  dtype="float32",
              )
              m = cv2.getPerspectiveTransform(src, dst)
              return cv2.warpPerspective(img, m, (size, size))
          except cv2.error:
              return None


      def split_into_cells(
          rectified: np.ndarray,
      ) -> Tuple[List[np.ndarray], np.ndarray]:
          """Return list with 81 cells (cropped)."""
          h, w = rectified.shape[:2]
          if h != w:
              size = max(h, w)
              rectified = cv2.resize(rectified, (size, size))
              h = w = size

          cell_size = h // GRID_SIZE
          margin = int(cell_size * 0.04)
          cells: list[np.ndarray] = []

          for r in range(GRID_SIZE):
              for c in range(GRID_SIZE):
                  y0 = r * cell_size + margin
                  x0 = c * cell_size + margin
                  y1 = (r + 1) * cell_size - margin
                  x1 = (c + 1) * cell_size - margin
                  if y0 >= y1 or x0 >= x1:
                      cell = np.zeros((cell_size, cell_size), rectified.dtype)
                  else:
                      cell = rectified[y0:y1, x0:x1]
                  cells.append(cell)

          return cells, rectified


      def extract_cells_from_image(
          img_or_path, *, size: int = DEFAULT_RECTIFIED_SIZE, debug: bool = False
      ):
          """High‑level convenience function."""
          if isinstance(img_or_path, (str, Path)):
              img = cv2.imread(str(img_or_path))
              if img is None:
                  return None, None, None
          elif isinstance(img_or_path, np.ndarray):
              img = img_or_path.copy()
          else:
              return None, None, None

          try:
              contour = find_sudoku_grid_contour(img, debug_dir=Path(f"debug_{os.getpid()}") if debug else None)
              rectified = rectify_grid(img, contour, size=size)
              if rectified is None:
                  return None, None, None
              cells, rectified = split_into_cells(rectified)
              return cells, rectified, contour
          except Exception as exc:
              print(f"[Extractor] {exc}")
              return None, None, None
    sudoku_recogniser.py: |
      # sudoku_recogniser.py
      """
      Command‑line utility: detect a Sudoku grid in an image and recognise its digits.
      """
      from __future__ import annotations

      import sys
      import time
      from pathlib import Path
      from typing import Tuple

      import cv2
      import numpy as np

      from digit_classifier import (
          EMPTY_LABEL,
          MODEL_FILENAME,
          DigitClassifier,
      )
      from digit_extractor import GRID_SIZE, extract_cells_from_image

      FINAL_CONFIDENCE_THRESHOLD = 0.80


      # --------------------------------------------------------------------------- #
      #  Pretty printing                                                            #
      # --------------------------------------------------------------------------- #
      def print_sudoku_grid(
          grid: np.ndarray,
          conf: np.ndarray | None = None,
          threshold: float = FINAL_CONFIDENCE_THRESHOLD,
      ) -> None:
          """Nicely print a 9×9 Sudoku grid."""
          grid = np.asarray(grid)
          if grid.shape != (GRID_SIZE, GRID_SIZE):
              print("[print_sudoku_grid] invalid shape")
              return

          for r in range(GRID_SIZE):
              if r and r % 3 == 0:
                  print("|-------+-------+-------|")

              line = []
              for c in range(GRID_SIZE):
                  d = grid[r, c]
                  if d == 0:
                      token = "."
                  else:
                      token = str(d)
                      if conf is not None and conf[r, c] < threshold:
                          token = "?"
                  line.append(token)

                  if (c + 1) % 3 == 0 and c != GRID_SIZE - 1:
                      line.append("|")
              print(" ".join(line))
          print()


      # --------------------------------------------------------------------------- #
      #  Overlay helper                                                             #
      # --------------------------------------------------------------------------- #
      def display_results_on_image(
          rectified: np.ndarray, grid: np.ndarray
      ) -> np.ndarray | None:
          """Draw recognised digits onto the rectified grid image."""
          if rectified is None:
              return None

          img = (
              cv2.cvtColor(rectified, cv2.COLOR_GRAY2BGR)
              if rectified.ndim == 2
              else rectified.copy()
          )
          h, w = img.shape[:2]
          cell_h, cell_w = h // GRID_SIZE, w // GRID_SIZE

          for r in range(GRID_SIZE):
              for c in range(GRID_SIZE):
                  d = grid[r, c]
                  if d == 0:
                      continue
                  text = str(d)
                  (tw, th), bl = cv2.getTextSize(text, cv2.FONT_HERSHEY_SIMPLEX, 1, 2)
                  x = c * cell_w + (cell_w - tw) // 2
                  y = r * cell_h + (cell_h + th) // 2
                  cv2.putText(
                      img,
                      text,
                      (x, y),
                      cv2.FONT_HERSHEY_SIMPLEX,
                      1,
                      (0, 255, 0),
                      2,
                      cv2.LINE_AA,
                  )
          return img


      # --------------------------------------------------------------------------- #
      #  Recognition pipeline                                                       #
      # --------------------------------------------------------------------------- #
      def recognise_sudoku(
          img_path: Path,
          classifier: DigitClassifier,
      ) -> Tuple[np.ndarray, np.ndarray, np.ndarray | None]:
          """Extract cells and run the classifier."""
          print(f"Processing {img_path} ...")
          start = time.time()
          cells, rectified, _ = extract_cells_from_image(img_path)
          if cells is None:
              raise RuntimeError("Extraction failed.")

          pred = np.zeros((GRID_SIZE, GRID_SIZE), int)
          conf = np.zeros_like(pred, float)

          for i, cell in enumerate(cells):
              r, c = divmod(i, GRID_SIZE)
              d, cf = classifier.recognise(cell, confidence_threshold=0.1)
              conf[r, c] = cf
              if d and cf >= FINAL_CONFIDENCE_THRESHOLD:
                  pred[r, c] = d

          print(f"Done in {time.time() - start:.2f}s")
          return pred, conf, rectified


      # --------------------------------------------------------------------------- #
      #  Entry‑point                                                                #
      # --------------------------------------------------------------------------- #
      def main() -> None:
          if len(sys.argv) < 2:
              print("Usage: sudoku_recogniser.py <image>")
              sys.exit(0)

          img_path = Path(sys.argv[1])
          if not img_path.exists():
              print("Image not found.")
              sys.exit(1)

          clf = DigitClassifier(model_path=MODEL_FILENAME)
          if clf.model is None:
              print("Model missing – training required.")
              clf.train()

          grid, conf, rectified = recognise_sudoku(img_path, clf)
          print_sudoku_grid(grid, conf)

          res = display_results_on_image(rectified, grid)
          if res is not None:
              cv2.imshow("Result", res)
              cv2.waitKey(0)
              cv2.destroyAllWindows()


      if __name__ == "__main__":
          main()
    sudoku_renderer.py: |
      # sudoku_renderer.py
      """
      Synthetic Sudoku image generator used for on‑the‑fly training data creation.
      """
      from __future__ import annotations

      import random
      from pathlib import Path
      from typing import Tuple

      import cv2
      import numpy as np
      import keras

      GRID_SIZE = 9
      BASE_IMAGE_SIZE = 1000
      CELL_SIZE = BASE_IMAGE_SIZE // GRID_SIZE
      MNIST_SIZE = 28


      def _order_points(pts: np.ndarray) -> np.ndarray:
          pts = pts.reshape(4, 2).astype("float32")
          rect = np.zeros((4, 2), dtype="float32")
          s = pts.sum(axis=1)
          rect[0] = pts[np.argmin(s)]
          rect[2] = pts[np.argmax(s)]
          diff = pts[:, 1] - pts[:, 0]
          rect[1] = pts[np.argmin(diff)]
          rect[3] = pts[np.argmax(diff)]
          return rect


      def _load_mnist_digits() -> dict[int, list[np.ndarray]]:
          """Download (once) and prepare MNIST for rendering digits."""
          (x_train, y_train), (x_test, y_test) = keras.datasets.mnist.load_data()
          imgs = np.concatenate([x_train, x_test])
          labels = np.concatenate([y_train, y_test])

          buckets: dict[int, list[np.ndarray]] = {i: [] for i in range(10)}
          for img, lbl in zip(imgs, labels):
              inv = cv2.bitwise_not(img)
              padded = cv2.copyMakeBorder(inv, 4, 4, 4, 4, cv2.BORDER_CONSTANT, value=255)
              buckets[int(lbl)].append(padded)
          return buckets


      class SudokuRenderer:
          """Render a random (optionally given) Sudoku grid to an image."""

          def __init__(self) -> None:
              self.mnist: dict[int, list[np.ndarray]] | None = None

          # --------------------------------------------------------------------- #
          #  Internals                                                            #
          # --------------------------------------------------------------------- #
          def _digit_source(self, digit: int) -> Tuple[np.ndarray | None, str]:
              srcs = []
              if self.mnist is None:
                  self.mnist = _load_mnist_digits()
              if self.mnist[digit]:
                  srcs.append("mnist")
              srcs.append("font")
              choice = random.choice(srcs)

              if choice == "mnist":
                  img = random.choice(self.mnist[digit])
                  if img.ndim == 2:
                      img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
                  return img, "mnist"
              return None, "font"

          # --------------------------------------------------------------------- #
          #  Public                                                               #
          # --------------------------------------------------------------------- #
          def render_sudoku(
              self,
              grid_spec: list[list[int | None]] | np.ndarray | None = None,
              *,
              allow_empty: bool = True,
          ):
              """Return (image, gt_grid, warped_corners)."""
              # ground truth ---------------------------------------------------- #
              if grid_spec is None:
                  gt = np.zeros((GRID_SIZE, GRID_SIZE), int)
                  for r in range(GRID_SIZE):
                      for c in range(GRID_SIZE):
                          if allow_empty and random.random() < 0.4:
                              continue
                          gt[r, c] = random.randint(1, 9)
              else:
                  gt = np.asarray([[d or 0 for d in row] for row in grid_spec], int)

              # canvas ----------------------------------------------------------- #
              bg_color = tuple(random.randint(200, 240) for _ in range(3))
              img = np.full((BASE_IMAGE_SIZE, BASE_IMAGE_SIZE, 3), bg_color, np.uint8)

              # grid lines ------------------------------------------------------- #
              for i in range(GRID_SIZE + 1):
                  major = i % 3 == 0
                  thick = random.randint(3 if major else 1, 5 if major else 3)
                  cv2.line(img, (0, i * CELL_SIZE), (BASE_IMAGE_SIZE, i * CELL_SIZE), (0, 0, 0), thick)
                  cv2.line(img, (i * CELL_SIZE, 0), (i * CELL_SIZE, BASE_IMAGE_SIZE), (0, 0, 0), thick)

              # digits ----------------------------------------------------------- #
              for r in range(GRID_SIZE):
                  for c in range(GRID_SIZE):
                      d = gt[r, c]
                      if d == 0:
                          continue

                      src_img, src_type = self._digit_source(d)
                      scale = random.uniform(0.5, 0.8)
                      tgt_h = tgt_w = int(CELL_SIZE * scale)
                      center_x = c * CELL_SIZE + CELL_SIZE // 2
                      center_y = r * CELL_SIZE + CELL_SIZE // 2
                      offset_x = int(random.uniform(-0.1, 0.1) * CELL_SIZE)
                      offset_y = int(random.uniform(-0.1, 0.1) * CELL_SIZE)
                      cx, cy = center_x + offset_x, center_y + offset_y

                      if src_type == "mnist":
                          rot = random.uniform(-10, 10)
                          M = cv2.getRotationMatrix2D((tgt_w / 2, tgt_h / 2), rot, 1)
                          digit = cv2.resize(src_img, (tgt_w, tgt_h))
                          digit = cv2.warpAffine(
                              digit,
                              M,
                              (tgt_w, tgt_h),
                              borderMode=cv2.BORDER_CONSTANT,
                              borderValue=(255, 255, 255),
                          )
                          mask = cv2.cvtColor(digit, cv2.COLOR_BGR2GRAY)
                          _, mask = cv2.threshold(mask, 250, 255, cv2.THRESH_BINARY_INV)

                          x0 = max(0, cx - tgt_w // 2)
                          y0 = max(0, cy - tgt_h // 2)
                          roi = img[y0 : y0 + tgt_h, x0 : x0 + tgt_w]
                          mask_inv = cv2.bitwise_not(mask[: roi.shape[0], : roi.shape[1]])
                          bg = cv2.bitwise_and(roi, roi, mask=mask_inv)
                          fg = cv2.bitwise_and(digit, digit, mask=mask[: roi.shape[0], : roi.shape[1]])
                          img[y0 : y0 + roi.shape[0], x0 : x0 + roi.shape[1]] = cv2.add(bg, fg)
                      else:  # font
                          font = cv2.FONT_HERSHEY_SIMPLEX
                          thickness = random.randint(1, 3)
                          font_scale = cv2.getFontScaleFromHeight(font, tgt_h, thickness) * 0.8
                          tw, th = cv2.getTextSize(str(d), font, font_scale, thickness)[0]
                          x = cx - tw // 2
                          y = cy + th // 2
                          cv2.putText(
                              img,
                              str(d),
                              (x, y),
                              font,
                              font_scale,
                              (0, 0, 0),
                              thickness,
                              cv2.LINE_AA,
                          )

              # noise ------------------------------------------------------------ #
              noise = np.random.normal(0, random.uniform(5, 20), img.shape).astype(np.float32)
              img = np.clip(img.astype(np.float32) + noise, 0, 255).astype(np.uint8)

              # perspective ------------------------------------------------------ #
              h, w = img.shape[:2]
              orig = np.array([[0, 0], [w - 1, 0], [w - 1, h - 1], [0, h - 1]], "float32")
              shift = random.uniform(0.05, 0.2)
              max_x, max_y = w * shift, h * shift
              dst = np.array(
                  [
                      [random.uniform(0, max_x), random.uniform(0, max_y)],
                      [w - 1 - random.uniform(0, max_x), random.uniform(0, max_y)],
                      [
                          w - 1 - random.uniform(-max_x * 0.2, max_x),
                          h - 1 - random.uniform(0, max_y * 0.5),
                      ],
                      [random.uniform(-max_x * 0.2, max_x), h - 1 - random.uniform(0, max_y * 0.5)],
                  ],
                  "float32",
              )
              M = cv2.getPerspectiveTransform(orig, dst)
              out_w, out_h = int(np.ceil(dst[:, 0].max())), int(np.ceil(dst[:, 1].max()))
              warped = cv2.warpPerspective(img, M, (out_w, out_h), borderMode=cv2.BORDER_REPLICATE)
              return warped, gt, dst


      # --------------------------------------------------------------------------- #
      #  Deterministic test example                                                 #
      # --------------------------------------------------------------------------- #
      def generate_and_save_test_example(
          prefix: str = "epoch_test_sudoku", *, force: bool = False
      ):
          img_path = Path(f"{prefix}.png")
          gt_path = Path(f"{prefix}_gt.npy")

          if not force and img_path.exists() and gt_path.exists():
              return str(img_path), np.load(gt_path)

          renderer = SudokuRenderer()
          img, gt, _ = renderer.render_sudoku(
              grid_spec=[
                  [None, None, 3, None, None, 6, None, 8, None],
                  [8, None, 1, None, 3, None, 5, None, 4],
                  [None, 4, None, 8, None, 7, None, 1, None],
                  [1, None, None, 4, None, 5, None, None, 9],
                  [None, 7, None, None, 2, None, None, 4, None],
                  [5, None, None, 7, None, 1, None, None, 3],
                  [None, 8, None, 5, None, 3, None, 9, None],
                  [7, None, 4, None, 9, None, 1, None, 8],
                  [None, 1, None, 6, None, None, 4, None, None],
              ]
          )
          cv2.imwrite(str(img_path), img)
          np.save(gt_path, gt)
          return str(img_path), gt
  diffs_applied_this_send: true
system:
  message: |2

    You are a helpful assistant.
    Respond in markdown format.
    Respond with the full code for any modified or added files. No placeholders.
    A git diff uses "+" or "-" at the start lines. Do NOT use "+" or "-" at the start of any line (unless incidental and not part of a git diff).
    Avoid asking the user to clear their caches or do local configuration related stuff. That's rarely the cause of errors.
    If you ask them, and they reply with a compilation error, assume they've already done everything you suggested and move on.
    But try to avoid such suggestions. It's a cop out. It's like when tech support says 'Have you tried turning it off and on again?'.
    Try to actually fix the error instead.
  model:
    - copy/paste
  code_completion_model:
    - copy/paste
  commit_message_model:
    - gemini/gemini-2.5-flash-preview-04-17
  max_completion_tokens:
  temperature: 0.0
  apply_mode: simple
messages:
  - user: |-
      ```python 'digit_classifier.py'
      # digit_classifier.py
      """
      Convolutional‑NN based digit classifier used by the Sudoku recogniser.

      The module can be executed directly to (re‑)train a model and run a
      quick smoke‑test afterwards.
      """
      from __future__ import annotations

      import gc
      import math
      import os
      import random
      from pathlib import Path
      from typing import Callable, Generator, Tuple

      import cv2
      import keras
      import numpy as np
      import torch
      from keras import callbacks, layers, models

      # --------------------------------------------------------------------------- #
      #  Configure Keras backend – keep this on top to make sure it applies early.  #
      # --------------------------------------------------------------------------- #
      os.environ["KERAS_BACKEND"] = "torch"

      # --------------------------------------------------------------------------- #
      #  Local imports (kept late to avoid circular / backend initialisation woes). #
      # --------------------------------------------------------------------------- #
      from sudoku_renderer import SudokuRenderer, generate_and_save_test_example
      from digit_extractor import (
          GRID_SIZE,
          extract_cells_from_image,
          rectify_grid,
          split_into_cells,
      )
      from sudoku_recogniser import (
          FINAL_CONFIDENCE_THRESHOLD,
          print_sudoku_grid,
      )

      # --------------------------------------------------------------------------- #
      #  Module constants                                                           #
      # --------------------------------------------------------------------------- #
      MODEL_FILENAME = "sudoku_digit_classifier_cnn.keras"
      MODEL_INPUT_SHAPE = (28, 28, 1)

      NUM_CLASSES = 11          # 0‑9 + one “empty” class
      EMPTY_LABEL = 10          # index of the empty class
      TARGET_CELL_CONTENT_SIZE = 24
      TARGET_DIGIT_RATIO = 1.5  # digits : empties within a batch

      EPOCHS = 40
      STEPS_PER_EPOCH = 150
      BATCH_SIZE = 128
      VALIDATION_STEPS = 50

      # --------------------------------------------------------------------------- #
      #  Data generator                                                             #
      # --------------------------------------------------------------------------- #
      DataBatch = Tuple[np.ndarray, np.ndarray]


      def sudoku_data_generator(
          renderer: SudokuRenderer,
          batch_size: int,
          preprocess_func: Callable[[np.ndarray], np.ndarray | None],
          input_size: tuple[int, int, int],
          target_digit_ratio: float = TARGET_DIGIT_RATIO,
      ) -> Generator[DataBatch, None, None]:
          """
          Yields balanced batches of *single‑cell* images and labels generated on‑the‑fly.
          """
          grid_size_sq = GRID_SIZE * GRID_SIZE
          target_digits = int(batch_size * (target_digit_ratio / (1 + target_digit_ratio)))
          target_empty = batch_size - target_digits
          input_h, input_w = input_size[:2]

          while True:
              x_batch, y_batch = [], []
              n_digits = n_empty = 0
              attempts, max_attempts = 0, batch_size * 4

              while len(x_batch) < batch_size and attempts < max_attempts:
                  attempts += 1
                  allow_empty = random.random() < 0.8
                  img, gt_grid, warped_corners = renderer.render_sudoku(allow_empty=allow_empty)
                  if img is None or warped_corners is None:
                      continue

                  try:
                      rectified = rectify_grid(img, warped_corners)
                      if rectified is None:
                          continue

                      cells, _ = split_into_cells(rectified)
                      if len(cells) != grid_size_sq:
                          continue
                  except Exception:
                      continue

                  gt_flat = gt_grid.flatten()
                  cell_indices = list(range(grid_size_sq))
                  random.shuffle(cell_indices)

                  for idx in cell_indices:
                      cell_img = cells[idx]
                      label = gt_flat[idx]
                      is_empty = label == 0
                      model_label = EMPTY_LABEL if is_empty else label

                      if is_empty and n_empty >= target_empty:
                          continue
                      if not is_empty and n_digits >= target_digits:
                          continue

                      processed = preprocess_func(cell_img)
                      if processed is None or processed.shape != (input_h, input_w):
                          continue

                      x_batch.append(processed)
                      y_batch.append(model_label)
                      if is_empty:
                          n_empty += 1
                      else:
                          n_digits += 1

                      if len(x_batch) >= batch_size:
                          break

              if not x_batch:
                  continue  # try again

              x_arr = np.expand_dims(np.asarray(x_batch, dtype="float32"), -1)
              y_arr = np.asarray(y_batch, dtype="int64")
              perm = np.random.permutation(len(y_arr))

              yield x_arr[perm], y_arr[perm]
              del x_batch, y_batch, x_arr, y_arr
              gc.collect()


      # --------------------------------------------------------------------------- #
      #  Epoch‑end callback                                                         #
      # --------------------------------------------------------------------------- #
      class EpochTestCallback(callbacks.Callback):
          """Evaluate the model on a fixed Sudoku after every *frequency* epochs."""

          def __init__(
              self,
              test_img: str | Path,
              gt_grid: np.ndarray,
              classifier: "DigitClassifier",
              frequency: int = 1,
          ) -> None:
              super().__init__()
              self.frequency = max(1, frequency)
              self.gt_grid = gt_grid
              self.classifier = classifier

              cells, *_ = extract_cells_from_image(test_img, debug=False)
              if not cells or len(cells) != GRID_SIZE * GRID_SIZE:
                  self.preprocessed = None
                  print("[Callback] Test image preparation failed – callback disabled.")
                  return

              processed = []
              for cell in cells:
                  proc = classifier._preprocess_cell_for_model(cell)
                  if proc is None:
                      proc = np.zeros(classifier._model_input_size, dtype="float32")
                  processed.append(proc)

              self.preprocessed = np.expand_dims(np.asarray(processed, dtype="float32"), -1)

          # --------------------------------------------------------------------- #
          def on_epoch_end(self, epoch: int, logs: dict | None = None) -> None:
              if self.preprocessed is None or (epoch + 1) % self.frequency:
                  return

              preds = self.model.predict(self.preprocessed, verbose=0)
              idxs = np.argmax(preds, axis=1)
              confs = np.max(preds, axis=1)

              final = []
              for i, c in zip(idxs, confs):
                  digit = 0
                  if i != EMPTY_LABEL and c >= FINAL_CONFIDENCE_THRESHOLD:
                      digit = i
                  final.append(digit)

              pred_grid = np.asarray(final).reshape(GRID_SIZE, GRID_SIZE)
              conf_grid = confs.reshape(GRID_SIZE, GRID_SIZE)

              print(f"\n--- Epoch {epoch + 1} test example ---")
              print("Ground truth:")
              print_sudoku_grid(self.gt_grid, threshold=1.1)

              print("\nPrediction:")
              print_sudoku_grid(pred_grid, conf_grid, threshold=FINAL_CONFIDENCE_THRESHOLD)

              correct = np.sum(pred_grid == self.gt_grid)
              print(f"Accuracy: {correct}/{GRID_SIZE**2} ({correct / GRID_SIZE**2:.4f})")
              print("--- end ---\n")


      # --------------------------------------------------------------------------- #
      #  DigitClassifier                                                             #
      # --------------------------------------------------------------------------- #
      class DigitClassifier:
          """
          Wraps model loading, training and inference.
          """

          def __init__(
              self,
              model_path: str | Path | None = None,
              training_required: bool = False,
          ) -> None:
              self.model_path = Path(model_path or MODEL_FILENAME)
              self.model: keras.Model | None = None
              self._model_input_size = MODEL_INPUT_SHAPE[:2]

              if not training_required and self.model_path.exists():
                  try:
                      self.model = keras.saving.load_model(self.model_path)
                      loaded_shape = self.model.input_shape[1:3]
                      if loaded_shape != self._model_input_size:
                          print(
                              f"[Warning] Model input shape {loaded_shape} "
                              f"!= expected {self._model_input_size}"
                          )
                      print("Model loaded.")
                  except Exception as exc:
                      print(f"[Error] Could not load model: {exc}")

          # --------------------------------------------------------------------- #
          #  Pre‑processing                                                       #
          # --------------------------------------------------------------------- #
          def _preprocess_cell_for_model(
              self, cell: np.ndarray
          ) -> np.ndarray | None:
              """
              Binarise, crop, centre, resize and normalise a single cell image.
              """
              tgt_h, tgt_w = self._model_input_size
              if cell is None or cell.size < 10:
                  return np.zeros((tgt_h, tgt_w), dtype="float32")

              gray = (
                  cv2.cvtColor(cell, cv2.COLOR_BGR2GRAY)
                  if cell.ndim == 3
                  else cell.copy()
              )

              blk = max(3, min(gray.shape) // 4) | 1  # ensure odd
              try:
                  thresh = cv2.adaptiveThreshold(
                      gray,
                      255,
                      cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                      cv2.THRESH_BINARY_INV,
                      blk,
                      7,
                  )
              except cv2.error:
                  return np.zeros((tgt_h, tgt_w), dtype="float32")

              coords = cv2.findNonZero(thresh)
              if coords is None:
                  return np.zeros((tgt_h, tgt_w), dtype="float32")

              x, y, w, h = cv2.boundingRect(coords)
              roi = thresh[y : y + h, x : x + w]
              if roi.size == 0:
                  return np.zeros((tgt_h, tgt_w), dtype="float32")

              scale = min(
                  TARGET_CELL_CONTENT_SIZE / max(1, w),
                  TARGET_CELL_CONTENT_SIZE / max(1, h),
              )
              new_w, new_h = max(1, int(w * scale)), max(1, int(h * scale))
              roi_resized = cv2.resize(roi, (new_w, new_h), interpolation=cv2.INTER_AREA)

              canvas = np.zeros((tgt_h, tgt_w), dtype=np.uint8)
              top = (tgt_h - new_h) // 2
              left = (tgt_w - new_w) // 2
              canvas[top : top + new_h, left : left + new_w] = roi_resized

              return canvas.astype("float32") / 255.0

          # --------------------------------------------------------------------- #
          #  Model architecture                                                   #
          # --------------------------------------------------------------------- #
          def _build_cnn_model(self) -> keras.Model:
              inp = keras.Input(shape=MODEL_INPUT_SHAPE)

              aug = keras.Sequential(
                  [
                      layers.RandomRotation(0.08, fill_mode="constant"),
                      layers.RandomTranslation(0.08, 0.08, fill_mode="constant"),
                      layers.RandomZoom(0.08, 0.08, fill_mode="constant"),
                  ],
                  name="augmentation",
              )
              x = aug(inp)

              # block 1
              for _ in range(2):
                  x = layers.Conv2D(32, (3, 3), padding="same")(x)
                  x = layers.BatchNormalization()(x)
                  x = layers.Activation("relu")(x)
              x = layers.MaxPooling2D((2, 2))(x)
              x = layers.Dropout(0.25)(x)

              # block 2
              for _ in range(2):
                  x = layers.Conv2D(64, (3, 3), padding="same")(x)
                  x = layers.BatchNormalization()(x)
                  x = layers.Activation("relu")(x)
              x = layers.MaxPooling2D((2, 2))(x)
              x = layers.Dropout(0.25)(x)

              x = layers.Flatten()(x)
              x = layers.Dense(128)(x)
              x = layers.BatchNormalization()(x)
              x = layers.Activation("relu")(x)
              x = layers.Dropout(0.5)(x)

              out = layers.Dense(NUM_CLASSES, activation="softmax")(x)

              model = models.Model(inp, out)
              model.compile(
                  optimizer=keras.optimizers.Adam(1e-3),
                  loss="sparse_categorical_crossentropy",
                  metrics=["accuracy"],
              )
              return model

          # --------------------------------------------------------------------- #
          #  Training                                                             #
          # --------------------------------------------------------------------- #
          def train(
              self,
              epochs: int = EPOCHS,
              steps_per_epoch: int = STEPS_PER_EPOCH,
              batch_size: int = BATCH_SIZE,
              validation_steps: int = VALIDATION_STEPS,
          ) -> None:
              print(
                  f"\nTraining parameters: {epochs=}, {steps_per_epoch=}, "
                  f"{batch_size=}, {validation_steps=}"
              )

              try:
                  test_img, test_gt = generate_and_save_test_example()
                  cb_epoch_test = EpochTestCallback(test_img, test_gt, self)
              except Exception as exc:
                  print(f"[Warn] Epoch test example unavailable: {exc}")
                  cb_epoch_test = None

              train_gen = sudoku_data_generator(
                  SudokuRenderer(),
                  batch_size,
                  self._preprocess_cell_for_model,
                  MODEL_INPUT_SHAPE,
              )
              val_gen = sudoku_data_generator(
                  SudokuRenderer(),
                  batch_size,
                  self._preprocess_cell_for_model,
                  MODEL_INPUT_SHAPE,
              )

              if self.model is None:
                  self.model = self._build_cnn_model()

              callbacks_list: list[callbacks.Callback] = [
                  callbacks.EarlyStopping(
                      monitor="val_loss",
                      patience=5,
                      restore_best_weights=True,
                      verbose=1,
                  ),
                  callbacks.ModelCheckpoint(
                      str(self.model_path),
                      monitor="val_loss",
                      save_best_only=True,
                      verbose=1,
                  ),
                  callbacks.ReduceLROnPlateau(
                      monitor="val_loss",
                      factor=0.2,
                      patience=3,
                      min_lr=1e-6,
                      verbose=1,
                  ),
              ]
              if cb_epoch_test and cb_epoch_test.preprocessed is not None:
                  callbacks_list.append(cb_epoch_test)

              self.model.fit(
                  train_gen,
                  epochs=epochs,
                  steps_per_epoch=steps_per_epoch,
                  validation_data=val_gen,
                  validation_steps=validation_steps,
                  callbacks=callbacks_list,
                  verbose=1,
              )

              # final evaluation
              print("\nFinal evaluation:")
              loss, acc = self.model.evaluate(
                  sudoku_data_generator(
                      SudokuRenderer(),
                      batch_size,
                      self._preprocess_cell_for_model,
                      MODEL_INPUT_SHAPE,
                  ),
                  steps=validation_steps,
                  verbose=1,
              )
              print(f"val_loss={loss:.4f}  val_acc={acc:.4f}")

              self.model.save(self.model_path)
              del train_gen, val_gen
              gc.collect()

          # --------------------------------------------------------------------- #
          #  Inference                                                            #
          # --------------------------------------------------------------------- #
          @torch.no_grad()
          def recognise(
              self,
              cell: np.ndarray,
              confidence_threshold: float = 0.7,
          ) -> Tuple[int, float]:
              """
              Return (digit, confidence). 0 means “empty / uncertain”.
              """
              if self.model is None:
                  return 0, 0.0

              proc = self._preprocess_cell_for_model(cell)
              if proc is None or proc.shape != self._model_input_size:
                  return 0, 0.0

              x = np.expand_dims(proc, (0, -1))
              x_tensor = torch.from_numpy(x).float()

              probs = self.model(x_tensor, training=False)[0]
              if isinstance(probs, torch.Tensor):
                  probs = probs.cpu().numpy()

              idx = int(np.argmax(probs))
              conf = float(probs[idx])

              if idx == EMPTY_LABEL or conf < confidence_threshold:
                  return 0, conf
              return idx, conf


      # --------------------------------------------------------------------------- #
      #  CLI / quick test                                                           #
      # --------------------------------------------------------------------------- #
      if __name__ == "__main__":
          FORCE_TRAIN = False
          if FORCE_TRAIN and Path(MODEL_FILENAME).exists():
              Path(MODEL_FILENAME).unlink()

          clf = DigitClassifier(training_required=FORCE_TRAIN)

          if clf.model is None:
              clf.train()

          if clf.model:
              print("\nQuick dummy test:")
              dummy = np.zeros((50, 50), dtype=np.uint8)
              cv2.line(dummy, (25, 10), (25, 40), 255, 3)
              d, c = clf.recognise(dummy, 0.5)
              print(f"Pred (vertical line) -> {d}  conf={c:.3f}")

              empty = np.zeros((50, 50), dtype=np.uint8)
              d, c = clf.recognise(empty, 0.5)
              print(f"Pred (blank)        -> {d}  conf={c:.3f}")

      ```
    metadata:
      filename: digit_classifier.py
  - user: |-
      ```python 'digit_extractor.py'
      # digit_extractor.py
      """
      Find a Sudoku grid in an image, rectify it and split it into 81 cell images.
      """
      from __future__ import annotations

      from pathlib import Path
      from typing import List, Tuple

      import cv2
      import numpy as np

      GRID_SIZE = 9
      DEFAULT_RECTIFIED_SIZE = 450


      # --------------------------------------------------------------------------- #
      #  Helpers                                                                    #
      # --------------------------------------------------------------------------- #
      def _order_points(pts: np.ndarray) -> np.ndarray:
          """Return points ordered TL, TR, BR, BL."""
          pts = pts.reshape(4, 2).astype("float32")
          rect = np.zeros((4, 2), dtype="float32")

          s = pts.sum(axis=1)
          rect[0] = pts[np.argmin(s)]
          rect[2] = pts[np.argmax(s)]

          diff = pts[:, 1] - pts[:, 0]
          rect[1] = pts[np.argmin(diff)]
          rect[3] = pts[np.argmax(diff)]
          return rect


      # --------------------------------------------------------------------------- #
      #  Core functionality                                                         #
      # --------------------------------------------------------------------------- #
      def find_sudoku_grid_contour(
          img: np.ndarray, *, debug_dir: Path | None = None
      ) -> np.ndarray:
          """Return a four‑point contour of the outer Sudoku boundary."""
          gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) if img.ndim == 3 else img.copy()

          if debug_dir:
              debug_dir.mkdir(parents=True, exist_ok=True)

          blur = cv2.GaussianBlur(gray, (7, 7), 0)
          thresh = cv2.adaptiveThreshold(
              blur,
              255,
              cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
              cv2.THRESH_BINARY_INV,
              15,
              4,
          )
          closed = cv2.morphologyEx(
              thresh,
              cv2.MORPH_CLOSE,
              cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3)),
              iterations=2,
          )

          contours, _ = cv2.findContours(
              closed, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE
          )
          contours = sorted(contours, key=cv2.contourArea, reverse=True)

          min_area = gray.size * 0.1
          for cnt in contours:
              if cv2.contourArea(cnt) < min_area:
                  break
              peri = cv2.arcLength(cnt, True)
              approx = cv2.approxPolyDP(cnt, 0.02 * peri, True)
              if len(approx) == 4 and cv2.isContourConvex(approx):
                  x, y, w, h = cv2.boundingRect(approx)
                  if 0.8 < w / h < 1.2:
                      return approx.reshape(4, 2).astype("float32")

          raise ValueError("Sudoku grid not found.")


      def rectify_grid(
          img: np.ndarray, contour: np.ndarray, *, size: int = DEFAULT_RECTIFIED_SIZE
      ) -> np.ndarray | None:
          """Perspective‑correct the Sudoku grid."""
          try:
              src = _order_points(contour)
              dst = np.array(
                  [[0, 0], [size - 1, 0], [size - 1, size - 1], [0, size - 1]],
                  dtype="float32",
              )
              m = cv2.getPerspectiveTransform(src, dst)
              return cv2.warpPerspective(img, m, (size, size))
          except cv2.error:
              return None


      def split_into_cells(
          rectified: np.ndarray,
      ) -> Tuple[List[np.ndarray], np.ndarray]:
          """Return list with 81 cells (cropped)."""
          h, w = rectified.shape[:2]
          if h != w:
              size = max(h, w)
              rectified = cv2.resize(rectified, (size, size))
              h = w = size

          cell_size = h // GRID_SIZE
          margin = int(cell_size * 0.04)
          cells: list[np.ndarray] = []

          for r in range(GRID_SIZE):
              for c in range(GRID_SIZE):
                  y0 = r * cell_size + margin
                  x0 = c * cell_size + margin
                  y1 = (r + 1) * cell_size - margin
                  x1 = (c + 1) * cell_size - margin
                  if y0 >= y1 or x0 >= x1:
                      cell = np.zeros((cell_size, cell_size), rectified.dtype)
                  else:
                      cell = rectified[y0:y1, x0:x1]
                  cells.append(cell)

          return cells, rectified


      def extract_cells_from_image(
          img_or_path, *, size: int = DEFAULT_RECTIFIED_SIZE, debug: bool = False
      ):
          """High‑level convenience function."""
          if isinstance(img_or_path, (str, Path)):
              img = cv2.imread(str(img_or_path))
              if img is None:
                  return None, None, None
          elif isinstance(img_or_path, np.ndarray):
              img = img_or_path.copy()
          else:
              return None, None, None

          try:
              contour = find_sudoku_grid_contour(img, debug_dir=Path(f"debug_{os.getpid()}") if debug else None)
              rectified = rectify_grid(img, contour, size=size)
              if rectified is None:
                  return None, None, None
              cells, rectified = split_into_cells(rectified)
              return cells, rectified, contour
          except Exception as exc:
              print(f"[Extractor] {exc}")
              return None, None, None

      ```
    metadata:
      filename: digit_extractor.py
  - user: |-
      ```python 'sudoku_recogniser.py'
      # sudoku_recogniser.py
      """
      Command‑line utility: detect a Sudoku grid in an image and recognise its digits.
      """
      from __future__ import annotations

      import sys
      import time
      from pathlib import Path
      from typing import Tuple

      import cv2
      import numpy as np

      from digit_classifier import (
          EMPTY_LABEL,
          MODEL_FILENAME,
          DigitClassifier,
      )
      from digit_extractor import GRID_SIZE, extract_cells_from_image

      FINAL_CONFIDENCE_THRESHOLD = 0.80


      # --------------------------------------------------------------------------- #
      #  Pretty printing                                                            #
      # --------------------------------------------------------------------------- #
      def print_sudoku_grid(
          grid: np.ndarray,
          conf: np.ndarray | None = None,
          threshold: float = FINAL_CONFIDENCE_THRESHOLD,
      ) -> None:
          """Nicely print a 9×9 Sudoku grid."""
          grid = np.asarray(grid)
          if grid.shape != (GRID_SIZE, GRID_SIZE):
              print("[print_sudoku_grid] invalid shape")
              return

          for r in range(GRID_SIZE):
              if r and r % 3 == 0:
                  print("|-------+-------+-------|")

              line = []
              for c in range(GRID_SIZE):
                  d = grid[r, c]
                  if d == 0:
                      token = "."
                  else:
                      token = str(d)
                      if conf is not None and conf[r, c] < threshold:
                          token = "?"
                  line.append(token)

                  if (c + 1) % 3 == 0 and c != GRID_SIZE - 1:
                      line.append("|")
              print(" ".join(line))
          print()


      # --------------------------------------------------------------------------- #
      #  Overlay helper                                                             #
      # --------------------------------------------------------------------------- #
      def display_results_on_image(
          rectified: np.ndarray, grid: np.ndarray
      ) -> np.ndarray | None:
          """Draw recognised digits onto the rectified grid image."""
          if rectified is None:
              return None

          img = (
              cv2.cvtColor(rectified, cv2.COLOR_GRAY2BGR)
              if rectified.ndim == 2
              else rectified.copy()
          )
          h, w = img.shape[:2]
          cell_h, cell_w = h // GRID_SIZE, w // GRID_SIZE

          for r in range(GRID_SIZE):
              for c in range(GRID_SIZE):
                  d = grid[r, c]
                  if d == 0:
                      continue
                  text = str(d)
                  (tw, th), bl = cv2.getTextSize(text, cv2.FONT_HERSHEY_SIMPLEX, 1, 2)
                  x = c * cell_w + (cell_w - tw) // 2
                  y = r * cell_h + (cell_h + th) // 2
                  cv2.putText(
                      img,
                      text,
                      (x, y),
                      cv2.FONT_HERSHEY_SIMPLEX,
                      1,
                      (0, 255, 0),
                      2,
                      cv2.LINE_AA,
                  )
          return img


      # --------------------------------------------------------------------------- #
      #  Recognition pipeline                                                       #
      # --------------------------------------------------------------------------- #
      def recognise_sudoku(
          img_path: Path,
          classifier: DigitClassifier,
      ) -> Tuple[np.ndarray, np.ndarray, np.ndarray | None]:
          """Extract cells and run the classifier."""
          print(f"Processing {img_path} ...")
          start = time.time()
          cells, rectified, _ = extract_cells_from_image(img_path)
          if cells is None:
              raise RuntimeError("Extraction failed.")

          pred = np.zeros((GRID_SIZE, GRID_SIZE), int)
          conf = np.zeros_like(pred, float)

          for i, cell in enumerate(cells):
              r, c = divmod(i, GRID_SIZE)
              d, cf = classifier.recognise(cell, confidence_threshold=0.1)
              conf[r, c] = cf
              if d and cf >= FINAL_CONFIDENCE_THRESHOLD:
                  pred[r, c] = d

          print(f"Done in {time.time() - start:.2f}s")
          return pred, conf, rectified


      # --------------------------------------------------------------------------- #
      #  Entry‑point                                                                #
      # --------------------------------------------------------------------------- #
      def main() -> None:
          if len(sys.argv) < 2:
              print("Usage: sudoku_recogniser.py <image>")
              sys.exit(0)

          img_path = Path(sys.argv[1])
          if not img_path.exists():
              print("Image not found.")
              sys.exit(1)

          clf = DigitClassifier(model_path=MODEL_FILENAME)
          if clf.model is None:
              print("Model missing – training required.")
              clf.train()

          grid, conf, rectified = recognise_sudoku(img_path, clf)
          print_sudoku_grid(grid, conf)

          res = display_results_on_image(rectified, grid)
          if res is not None:
              cv2.imshow("Result", res)
              cv2.waitKey(0)
              cv2.destroyAllWindows()


      if __name__ == "__main__":
          main()

      ```
    metadata:
      filename: sudoku_recogniser.py
  - user: |-
      ```python 'sudoku_renderer.py'
      # sudoku_renderer.py
      """
      Synthetic Sudoku image generator used for on‑the‑fly training data creation.
      """
      from __future__ import annotations

      import random
      from pathlib import Path
      from typing import Tuple

      import cv2
      import numpy as np
      import keras

      GRID_SIZE = 9
      BASE_IMAGE_SIZE = 1000
      CELL_SIZE = BASE_IMAGE_SIZE // GRID_SIZE
      MNIST_SIZE = 28


      def _order_points(pts: np.ndarray) -> np.ndarray:
          pts = pts.reshape(4, 2).astype("float32")
          rect = np.zeros((4, 2), dtype="float32")
          s = pts.sum(axis=1)
          rect[0] = pts[np.argmin(s)]
          rect[2] = pts[np.argmax(s)]
          diff = pts[:, 1] - pts[:, 0]
          rect[1] = pts[np.argmin(diff)]
          rect[3] = pts[np.argmax(diff)]
          return rect


      def _load_mnist_digits() -> dict[int, list[np.ndarray]]:
          """Download (once) and prepare MNIST for rendering digits."""
          (x_train, y_train), (x_test, y_test) = keras.datasets.mnist.load_data()
          imgs = np.concatenate([x_train, x_test])
          labels = np.concatenate([y_train, y_test])

          buckets: dict[int, list[np.ndarray]] = {i: [] for i in range(10)}
          for img, lbl in zip(imgs, labels):
              inv = cv2.bitwise_not(img)
              padded = cv2.copyMakeBorder(inv, 4, 4, 4, 4, cv2.BORDER_CONSTANT, value=255)
              buckets[int(lbl)].append(padded)
          return buckets


      class SudokuRenderer:
          """Render a random (optionally given) Sudoku grid to an image."""

          def __init__(self) -> None:
              self.mnist: dict[int, list[np.ndarray]] | None = None

          # --------------------------------------------------------------------- #
          #  Internals                                                            #
          # --------------------------------------------------------------------- #
          def _digit_source(self, digit: int) -> Tuple[np.ndarray | None, str]:
              srcs = []
              if self.mnist is None:
                  self.mnist = _load_mnist_digits()
              if self.mnist[digit]:
                  srcs.append("mnist")
              srcs.append("font")
              choice = random.choice(srcs)

              if choice == "mnist":
                  img = random.choice(self.mnist[digit])
                  if img.ndim == 2:
                      img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
                  return img, "mnist"
              return None, "font"

          # --------------------------------------------------------------------- #
          #  Public                                                               #
          # --------------------------------------------------------------------- #
          def render_sudoku(
              self,
              grid_spec: list[list[int | None]] | np.ndarray | None = None,
              *,
              allow_empty: bool = True,
          ):
              """Return (image, gt_grid, warped_corners)."""
              # ground truth ---------------------------------------------------- #
              if grid_spec is None:
                  gt = np.zeros((GRID_SIZE, GRID_SIZE), int)
                  for r in range(GRID_SIZE):
                      for c in range(GRID_SIZE):
                          if allow_empty and random.random() < 0.4:
                              continue
                          gt[r, c] = random.randint(1, 9)
              else:
                  gt = np.asarray([[d or 0 for d in row] for row in grid_spec], int)

              # canvas ----------------------------------------------------------- #
              bg_color = tuple(random.randint(200, 240) for _ in range(3))
              img = np.full((BASE_IMAGE_SIZE, BASE_IMAGE_SIZE, 3), bg_color, np.uint8)

              # grid lines ------------------------------------------------------- #
              for i in range(GRID_SIZE + 1):
                  major = i % 3 == 0
                  thick = random.randint(3 if major else 1, 5 if major else 3)
                  cv2.line(img, (0, i * CELL_SIZE), (BASE_IMAGE_SIZE, i * CELL_SIZE), (0, 0, 0), thick)
                  cv2.line(img, (i * CELL_SIZE, 0), (i * CELL_SIZE, BASE_IMAGE_SIZE), (0, 0, 0), thick)

              # digits ----------------------------------------------------------- #
              for r in range(GRID_SIZE):
                  for c in range(GRID_SIZE):
                      d = gt[r, c]
                      if d == 0:
                          continue

                      src_img, src_type = self._digit_source(d)
                      scale = random.uniform(0.5, 0.8)
                      tgt_h = tgt_w = int(CELL_SIZE * scale)
                      center_x = c * CELL_SIZE + CELL_SIZE // 2
                      center_y = r * CELL_SIZE + CELL_SIZE // 2
                      offset_x = int(random.uniform(-0.1, 0.1) * CELL_SIZE)
                      offset_y = int(random.uniform(-0.1, 0.1) * CELL_SIZE)
                      cx, cy = center_x + offset_x, center_y + offset_y

                      if src_type == "mnist":
                          rot = random.uniform(-10, 10)
                          M = cv2.getRotationMatrix2D((tgt_w / 2, tgt_h / 2), rot, 1)
                          digit = cv2.resize(src_img, (tgt_w, tgt_h))
                          digit = cv2.warpAffine(
                              digit,
                              M,
                              (tgt_w, tgt_h),
                              borderMode=cv2.BORDER_CONSTANT,
                              borderValue=(255, 255, 255),
                          )
                          mask = cv2.cvtColor(digit, cv2.COLOR_BGR2GRAY)
                          _, mask = cv2.threshold(mask, 250, 255, cv2.THRESH_BINARY_INV)

                          x0 = max(0, cx - tgt_w // 2)
                          y0 = max(0, cy - tgt_h // 2)
                          roi = img[y0 : y0 + tgt_h, x0 : x0 + tgt_w]
                          mask_inv = cv2.bitwise_not(mask[: roi.shape[0], : roi.shape[1]])
                          bg = cv2.bitwise_and(roi, roi, mask=mask_inv)
                          fg = cv2.bitwise_and(digit, digit, mask=mask[: roi.shape[0], : roi.shape[1]])
                          img[y0 : y0 + roi.shape[0], x0 : x0 + roi.shape[1]] = cv2.add(bg, fg)
                      else:  # font
                          font = cv2.FONT_HERSHEY_SIMPLEX
                          thickness = random.randint(1, 3)
                          font_scale = cv2.getFontScaleFromHeight(font, tgt_h, thickness) * 0.8
                          tw, th = cv2.getTextSize(str(d), font, font_scale, thickness)[0]
                          x = cx - tw // 2
                          y = cy + th // 2
                          cv2.putText(
                              img,
                              str(d),
                              (x, y),
                              font,
                              font_scale,
                              (0, 0, 0),
                              thickness,
                              cv2.LINE_AA,
                          )

              # noise ------------------------------------------------------------ #
              noise = np.random.normal(0, random.uniform(5, 20), img.shape).astype(np.float32)
              img = np.clip(img.astype(np.float32) + noise, 0, 255).astype(np.uint8)

              # perspective ------------------------------------------------------ #
              h, w = img.shape[:2]
              orig = np.array([[0, 0], [w - 1, 0], [w - 1, h - 1], [0, h - 1]], "float32")
              shift = random.uniform(0.05, 0.2)
              max_x, max_y = w * shift, h * shift
              dst = np.array(
                  [
                      [random.uniform(0, max_x), random.uniform(0, max_y)],
                      [w - 1 - random.uniform(0, max_x), random.uniform(0, max_y)],
                      [
                          w - 1 - random.uniform(-max_x * 0.2, max_x),
                          h - 1 - random.uniform(0, max_y * 0.5),
                      ],
                      [random.uniform(-max_x * 0.2, max_x), h - 1 - random.uniform(0, max_y * 0.5)],
                  ],
                  "float32",
              )
              M = cv2.getPerspectiveTransform(orig, dst)
              out_w, out_h = int(np.ceil(dst[:, 0].max())), int(np.ceil(dst[:, 1].max()))
              warped = cv2.warpPerspective(img, M, (out_w, out_h), borderMode=cv2.BORDER_REPLICATE)
              return warped, gt, dst


      # --------------------------------------------------------------------------- #
      #  Deterministic test example                                                 #
      # --------------------------------------------------------------------------- #
      def generate_and_save_test_example(
          prefix: str = "epoch_test_sudoku", *, force: bool = False
      ):
          img_path = Path(f"{prefix}.png")
          gt_path = Path(f"{prefix}_gt.npy")

          if not force and img_path.exists() and gt_path.exists():
              return str(img_path), np.load(gt_path)

          renderer = SudokuRenderer()
          img, gt, _ = renderer.render_sudoku(
              grid_spec=[
                  [None, None, 3, None, None, 6, None, 8, None],
                  [8, None, 1, None, 3, None, 5, None, 4],
                  [None, 4, None, 8, None, 7, None, 1, None],
                  [1, None, None, 4, None, 5, None, None, 9],
                  [None, 7, None, None, 2, None, None, 4, None],
                  [5, None, None, 7, None, 1, None, None, 3],
                  [None, 8, None, 5, None, 3, None, 9, None],
                  [7, None, 4, None, 9, None, 1, None, 8],
                  [None, 1, None, 6, None, None, 4, None, None],
              ]
          )
          cv2.imwrite(str(img_path), img)
          np.save(gt_path, gt)
          return str(img_path), gt

      ```
    metadata:
      filename: sudoku_renderer.py
  - user: |-
      Clean up this code. Don't change its functionality, and don't try any grand alterations to its design. Just make it cleaner and more presentable.
      e.g. there's a lot of superfluous comments like "v6..." or "let's try this way" or "this is wrong... here is how we fix it".
      Write the full code for all files.
    metadata:
  - assistant: |-
      Certainly! Here is your code, cleaned up for clarity and presentation, with unnecessary comments and clutter removed, and formatting improved. No functionality has been changed.

      ---

      ### `digit_classifier.py`

      ```python
      # digit_classifier.py
      """
      Convolutional-NN based digit classifier used by the Sudoku recogniser.

      The module can be executed directly to (re-)train a model and run a
      quick smoke-test afterwards.
      """
      from __future__ import annotations

      import gc
      import os
      import random
      from pathlib import Path
      from typing import Callable, Generator, Tuple

      import cv2
      import keras
      import numpy as np
      import torch
      from keras import callbacks, layers, models

      os.environ["KERAS_BACKEND"] = "torch"

      from sudoku_renderer import SudokuRenderer, generate_and_save_test_example
      from digit_extractor import (
          GRID_SIZE,
          extract_cells_from_image,
          rectify_grid,
          split_into_cells,
      )
      from sudoku_recogniser import (
          FINAL_CONFIDENCE_THRESHOLD,
          print_sudoku_grid,
      )

      MODEL_FILENAME = "sudoku_digit_classifier_cnn.keras"
      MODEL_INPUT_SHAPE = (28, 28, 1)
      NUM_CLASSES = 11          # 0-9 + one “empty” class
      EMPTY_LABEL = 10          # index of the empty class
      TARGET_CELL_CONTENT_SIZE = 24
      TARGET_DIGIT_RATIO = 1.5  # digits : empties within a batch

      EPOCHS = 40
      STEPS_PER_EPOCH = 150
      BATCH_SIZE = 128
      VALIDATION_STEPS = 50

      DataBatch = Tuple[np.ndarray, np.ndarray]


      def sudoku_data_generator(
          renderer: SudokuRenderer,
          batch_size: int,
          preprocess_func: Callable[[np.ndarray], np.ndarray | None],
          input_size: tuple[int, int, int],
          target_digit_ratio: float = TARGET_DIGIT_RATIO,
      ) -> Generator[DataBatch, None, None]:
          """
          Yields balanced batches of single-cell images and labels generated on-the-fly.
          """
          grid_size_sq = GRID_SIZE * GRID_SIZE
          target_digits = int(batch_size * (target_digit_ratio / (1 + target_digit_ratio)))
          target_empty = batch_size - target_digits
          input_h, input_w = input_size[:2]

          while True:
              x_batch, y_batch = [], []
              n_digits = n_empty = 0
              attempts, max_attempts = 0, batch_size * 4

              while len(x_batch) < batch_size and attempts < max_attempts:
                  attempts += 1
                  allow_empty = random.random() < 0.8
                  img, gt_grid, warped_corners = renderer.render_sudoku(allow_empty=allow_empty)
                  if img is None or warped_corners is None:
                      continue

                  try:
                      rectified = rectify_grid(img, warped_corners)
                      if rectified is None:
                          continue

                      cells, _ = split_into_cells(rectified)
                      if len(cells) != grid_size_sq:
                          continue
                  except Exception:
                      continue

                  gt_flat = gt_grid.flatten()
                  cell_indices = list(range(grid_size_sq))
                  random.shuffle(cell_indices)

                  for idx in cell_indices:
                      cell_img = cells[idx]
                      label = gt_flat[idx]
                      is_empty = label == 0
                      model_label = EMPTY_LABEL if is_empty else label

                      if is_empty and n_empty >= target_empty:
                          continue
                      if not is_empty and n_digits >= target_digits:
                          continue

                      processed = preprocess_func(cell_img)
                      if processed is None or processed.shape != (input_h, input_w):
                          continue

                      x_batch.append(processed)
                      y_batch.append(model_label)
                      if is_empty:
                          n_empty += 1
                      else:
                          n_digits += 1

                      if len(x_batch) >= batch_size:
                          break

              if not x_batch:
                  continue

              x_arr = np.expand_dims(np.asarray(x_batch, dtype="float32"), -1)
              y_arr = np.asarray(y_batch, dtype="int64")
              perm = np.random.permutation(len(y_arr))

              yield x_arr[perm], y_arr[perm]
              del x_batch, y_batch, x_arr, y_arr
              gc.collect()


      class EpochTestCallback(callbacks.Callback):
          """Evaluate the model on a fixed Sudoku after every *frequency* epochs."""

          def __init__(
              self,
              test_img: str | Path,
              gt_grid: np.ndarray,
              classifier: "DigitClassifier",
              frequency: int = 1,
          ) -> None:
              super().__init__()
              self.frequency = max(1, frequency)
              self.gt_grid = gt_grid
              self.classifier = classifier

              cells, *_ = extract_cells_from_image(test_img, debug=False)
              if not cells or len(cells) != GRID_SIZE * GRID_SIZE:
                  self.preprocessed = None
                  print("[Callback] Test image preparation failed – callback disabled.")
                  return

              processed = []
              for cell in cells:
                  proc = classifier._preprocess_cell_for_model(cell)
                  if proc is None:
                      proc = np.zeros(classifier._model_input_size, dtype="float32")
                  processed.append(proc)

              self.preprocessed = np.expand_dims(np.asarray(processed, dtype="float32"), -1)

          def on_epoch_end(self, epoch: int, logs: dict | None = None) -> None:
              if self.preprocessed is None or (epoch + 1) % self.frequency:
                  return

              preds = self.model.predict(self.preprocessed, verbose=0)
              idxs = np.argmax(preds, axis=1)
              confs = np.max(preds, axis=1)

              final = []
              for i, c in zip(idxs, confs):
                  digit = 0
                  if i != EMPTY_LABEL and c >= FINAL_CONFIDENCE_THRESHOLD:
                      digit = i
                  final.append(digit)

              pred_grid = np.asarray(final).reshape(GRID_SIZE, GRID_SIZE)
              conf_grid = confs.reshape(GRID_SIZE, GRID_SIZE)

              print(f"\n--- Epoch {epoch + 1} test example ---")
              print("Ground truth:")
              print_sudoku_grid(self.gt_grid, threshold=1.1)

              print("\nPrediction:")
              print_sudoku_grid(pred_grid, conf_grid, threshold=FINAL_CONFIDENCE_THRESHOLD)

              correct = np.sum(pred_grid == self.gt_grid)
              print(f"Accuracy: {correct}/{GRID_SIZE**2} ({correct / GRID_SIZE**2:.4f})")
              print("--- end ---\n")


      class DigitClassifier:
          """
          Wraps model loading, training and inference.
          """

          def __init__(
              self,
              model_path: str | Path | None = None,
              training_required: bool = False,
          ) -> None:
              self.model_path = Path(model_path or MODEL_FILENAME)
              self.model: keras.Model | None = None
              self._model_input_size = MODEL_INPUT_SHAPE[:2]

              if not training_required and self.model_path.exists():
                  try:
                      self.model = keras.saving.load_model(self.model_path)
                      loaded_shape = self.model.input_shape[1:3]
                      if loaded_shape != self._model_input_size:
                          print(
                              f"[Warning] Model input shape {loaded_shape} "
                              f"!= expected {self._model_input_size}"
                          )
                      print("Model loaded.")
                  except Exception as exc:
                      print(f"[Error] Could not load model: {exc}")

          def _preprocess_cell_for_model(
              self, cell: np.ndarray
          ) -> np.ndarray | None:
              """
              Binarise, crop, centre, resize and normalise a single cell image.
              """
              tgt_h, tgt_w = self._model_input_size
              if cell is None or cell.size < 10:
                  return np.zeros((tgt_h, tgt_w), dtype="float32")

              gray = (
                  cv2.cvtColor(cell, cv2.COLOR_BGR2GRAY)
                  if cell.ndim == 3
                  else cell.copy()
              )

              blk = max(3, min(gray.shape) // 4) | 1  # ensure odd
              try:
                  thresh = cv2.adaptiveThreshold(
                      gray,
                      255,
                      cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                      cv2.THRESH_BINARY_INV,
                      blk,
                      7,
                  )
              except cv2.error:
                  return np.zeros((tgt_h, tgt_w), dtype="float32")

              coords = cv2.findNonZero(thresh)
              if coords is None:
                  return np.zeros((tgt_h, tgt_w), dtype="float32")

              x, y, w, h = cv2.boundingRect(coords)
              roi = thresh[y : y + h, x : x + w]
              if roi.size == 0:
                  return np.zeros((tgt_h, tgt_w), dtype="float32")

              scale = min(
                  TARGET_CELL_CONTENT_SIZE / max(1, w),
                  TARGET_CELL_CONTENT_SIZE / max(1, h),
              )
              new_w, new_h = max(1, int(w * scale)), max(1, int(h * scale))
              roi_resized = cv2.resize(roi, (new_w, new_h), interpolation=cv2.INTER_AREA)

              canvas = np.zeros((tgt_h, tgt_w), dtype=np.uint8)
              top = (tgt_h - new_h) // 2
              left = (tgt_w - new_w) // 2
              canvas[top : top + new_h, left : left + new_w] = roi_resized

              return canvas.astype("float32") / 255.0

          def _build_cnn_model(self) -> keras.Model:
              inp = keras.Input(shape=MODEL_INPUT_SHAPE)

              aug = keras.Sequential(
                  [
                      layers.RandomRotation(0.08, fill_mode="constant"),
                      layers.RandomTranslation(0.08, 0.08, fill_mode="constant"),
                      layers.RandomZoom(0.08, 0.08, fill_mode="constant"),
                  ],
                  name="augmentation",
              )
              x = aug(inp)

              for _ in range(2):
                  x = layers.Conv2D(32, (3, 3), padding="same")(x)
                  x = layers.BatchNormalization()(x)
                  x = layers.Activation("relu")(x)
              x = layers.MaxPooling2D((2, 2))(x)
              x = layers.Dropout(0.25)(x)

              for _ in range(2):
                  x = layers.Conv2D(64, (3, 3), padding="same")(x)
                  x = layers.BatchNormalization()(x)
                  x = layers.Activation("relu")(x)
              x = layers.MaxPooling2D((2, 2))(x)
              x = layers.Dropout(0.25)(x)

              x = layers.Flatten()(x)
              x = layers.Dense(128)(x)
              x = layers.BatchNormalization()(x)
              x = layers.Activation("relu")(x)
              x = layers.Dropout(0.5)(x)

              out = layers.Dense(NUM_CLASSES, activation="softmax")(x)

              model = models.Model(inp, out)
              model.compile(
                  optimizer=keras.optimizers.Adam(1e-3),
                  loss="sparse_categorical_crossentropy",
                  metrics=["accuracy"],
              )
              return model

          def train(
              self,
              epochs: int = EPOCHS,
              steps_per_epoch: int = STEPS_PER_EPOCH,
              batch_size: int = BATCH_SIZE,
              validation_steps: int = VALIDATION_STEPS,
          ) -> None:
              print(
                  f"\nTraining parameters: {epochs=}, {steps_per_epoch=}, "
                  f"{batch_size=}, {validation_steps=}"
              )

              try:
                  test_img, test_gt = generate_and_save_test_example()
                  cb_epoch_test = EpochTestCallback(test_img, test_gt, self)
              except Exception as exc:
                  print(f"[Warn] Epoch test example unavailable: {exc}")
                  cb_epoch_test = None

              train_gen = sudoku_data_generator(
                  SudokuRenderer(),
                  batch_size,
                  self._preprocess_cell_for_model,
                  MODEL_INPUT_SHAPE,
              )
              val_gen = sudoku_data_generator(
                  SudokuRenderer(),
                  batch_size,
                  self._preprocess_cell_for_model,
                  MODEL_INPUT_SHAPE,
              )

              if self.model is None:
                  self.model = self._build_cnn_model()

              callbacks_list: list[callbacks.Callback] = [
                  callbacks.EarlyStopping(
                      monitor="val_loss",
                      patience=5,
                      restore_best_weights=True,
                      verbose=1,
                  ),
                  callbacks.ModelCheckpoint(
                      str(self.model_path),
                      monitor="val_loss",
                      save_best_only=True,
                      verbose=1,
                  ),
                  callbacks.ReduceLROnPlateau(
                      monitor="val_loss",
                      factor=0.2,
                      patience=3,
                      min_lr=1e-6,
                      verbose=1,
                  ),
              ]
              if cb_epoch_test and cb_epoch_test.preprocessed is not None:
                  callbacks_list.append(cb_epoch_test)

              self.model.fit(
                  train_gen,
                  epochs=epochs,
                  steps_per_epoch=steps_per_epoch,
                  validation_data=val_gen,
                  validation_steps=validation_steps,
                  callbacks=callbacks_list,
                  verbose=1,
              )

              print("\nFinal evaluation:")
              loss, acc = self.model.evaluate(
                  sudoku_data_generator(
                      SudokuRenderer(),
                      batch_size,
                      self._preprocess_cell_for_model,
                      MODEL_INPUT_SHAPE,
                  ),
                  steps=validation_steps,
                  verbose=1,
              )
              print(f"val_loss={loss:.4f}  val_acc={acc:.4f}")

              self.model.save(self.model_path)
              del train_gen, val_gen
              gc.collect()

          @torch.no_grad()
          def recognise(
              self,
              cell: np.ndarray,
              confidence_threshold: float = 0.7,
          ) -> Tuple[int, float]:
              """
              Return (digit, confidence). 0 means “empty / uncertain”.
              """
              if self.model is None:
                  return 0, 0.0

              proc = self._preprocess_cell_for_model(cell)
              if proc is None or proc.shape != self._model_input_size:
                  return 0, 0.0

              x = np.expand_dims(proc, (0, -1))
              x_tensor = torch.from_numpy(x).float()

              probs = self.model(x_tensor, training=False)[0]
              if isinstance(probs, torch.Tensor):
                  probs = probs.cpu().numpy()

              idx = int(np.argmax(probs))
              conf = float(probs[idx])

              if idx == EMPTY_LABEL or conf < confidence_threshold:
                  return 0, conf
              return idx, conf


      if __name__ == "__main__":
          FORCE_TRAIN = False
          if FORCE_TRAIN and Path(MODEL_FILENAME).exists():
              Path(MODEL_FILENAME).unlink()

          clf = DigitClassifier(training_required=FORCE_TRAIN)

          if clf.model is None:
              clf.train()

          if clf.model:
              print("\nQuick dummy test:")
              dummy = np.zeros((50, 50), dtype=np.uint8)
              cv2.line(dummy, (25, 10), (25, 40), 255, 3)
              d, c = clf.recognise(dummy, 0.5)
              print(f"Pred (vertical line) -> {d}  conf={c:.3f}")

              empty = np.zeros((50, 50), dtype=np.uint8)
              d, c = clf.recognise(empty, 0.5)
              print(f"Pred (blank)        -> {d}  conf={c:.3f}")
      ```

      ---

      ### `digit_extractor.py`

      ```python
      # digit_extractor.py
      """
      Find a Sudoku grid in an image, rectify it and split it into 81 cell images.
      """
      from __future__ import annotations

      import os
      from pathlib import Path
      from typing import List, Tuple

      import cv2
      import numpy as np

      GRID_SIZE = 9
      DEFAULT_RECTIFIED_SIZE = 450


      def _order_points(pts: np.ndarray) -> np.ndarray:
          """Return points ordered TL, TR, BR, BL."""
          pts = pts.reshape(4, 2).astype("float32")
          rect = np.zeros((4, 2), dtype="float32")

          s = pts.sum(axis=1)
          rect[0] = pts[np.argmin(s)]
          rect[2] = pts[np.argmax(s)]

          diff = pts[:, 1] - pts[:, 0]
          rect[1] = pts[np.argmin(diff)]
          rect[3] = pts[np.argmax(diff)]
          return rect


      def find_sudoku_grid_contour(
          img: np.ndarray, *, debug_dir: Path | None = None
      ) -> np.ndarray:
          """Return a four-point contour of the outer Sudoku boundary."""
          gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) if img.ndim == 3 else img.copy()

          if debug_dir:
              debug_dir.mkdir(parents=True, exist_ok=True)

          blur = cv2.GaussianBlur(gray, (7, 7), 0)
          thresh = cv2.adaptiveThreshold(
              blur,
              255,
              cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
              cv2.THRESH_BINARY_INV,
              15,
              4,
          )
          closed = cv2.morphologyEx(
              thresh,
              cv2.MORPH_CLOSE,
              cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3)),
              iterations=2,
          )

          contours, _ = cv2.findContours(
              closed, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE
          )
          contours = sorted(contours, key=cv2.contourArea, reverse=True)

          min_area = gray.size * 0.1
          for cnt in contours:
              if cv2.contourArea(cnt) < min_area:
                  break
              peri = cv2.arcLength(cnt, True)
              approx = cv2.approxPolyDP(cnt, 0.02 * peri, True)
              if len(approx) == 4 and cv2.isContourConvex(approx):
                  x, y, w, h = cv2.boundingRect(approx)
                  if 0.8 < w / h < 1.2:
                      return approx.reshape(4, 2).astype("float32")

          raise ValueError("Sudoku grid not found.")


      def rectify_grid(
          img: np.ndarray, contour: np.ndarray, *, size: int = DEFAULT_RECTIFIED_SIZE
      ) -> np.ndarray | None:
          """Perspective-correct the Sudoku grid."""
          try:
              src = _order_points(contour)
              dst = np.array(
                  [[0, 0], [size - 1, 0], [size - 1, size - 1], [0, size - 1]],
                  dtype="float32",
              )
              m = cv2.getPerspectiveTransform(src, dst)
              return cv2.warpPerspective(img, m, (size, size))
          except cv2.error:
              return None


      def split_into_cells(
          rectified: np.ndarray,
      ) -> Tuple[List[np.ndarray], np.ndarray]:
          """Return list with 81 cells (cropped)."""
          h, w = rectified.shape[:2]
          if h != w:
              size = max(h, w)
              rectified = cv2.resize(rectified, (size, size))
              h = w = size

          cell_size = h // GRID_SIZE
          margin = int(cell_size * 0.04)
          cells: list[np.ndarray] = []

          for r in range(GRID_SIZE):
              for c in range(GRID_SIZE):
                  y0 = r * cell_size + margin
                  x0 = c * cell_size + margin
                  y1 = (r + 1) * cell_size - margin
                  x1 = (c + 1) * cell_size - margin
                  if y0 >= y1 or x0 >= x1:
                      cell = np.zeros((cell_size, cell_size), rectified.dtype)
                  else:
                      cell = rectified[y0:y1, x0:x1]
                  cells.append(cell)

          return cells, rectified


      def extract_cells_from_image(
          img_or_path, *, size: int = DEFAULT_RECTIFIED_SIZE, debug: bool = False
      ):
          """High-level convenience function."""
          if isinstance(img_or_path, (str, Path)):
              img = cv2.imread(str(img_or_path))
              if img is None:
                  return None, None, None
          elif isinstance(img_or_path, np.ndarray):
              img = img_or_path.copy()
          else:
              return None, None, None

          try:
              contour = find_sudoku_grid_contour(img, debug_dir=Path(f"debug_{os.getpid()}") if debug else None)
              rectified = rectify_grid(img, contour, size=size)
              if rectified is None:
                  return None, None, None
              cells, rectified = split_into_cells(rectified)
              return cells, rectified, contour
          except Exception as exc:
              print(f"[Extractor] {exc}")
              return None, None, None
      ```

      ---

      ### `sudoku_recogniser.py`

      ```python
      # sudoku_recogniser.py
      """
      Command-line utility: detect a Sudoku grid in an image and recognise its digits.
      """
      from __future__ import annotations

      import sys
      import time
      from pathlib import Path
      from typing import Tuple

      import cv2
      import numpy as np

      from digit_classifier import (
          EMPTY_LABEL,
          MODEL_FILENAME,
          DigitClassifier,
      )
      from digit_extractor import GRID_SIZE, extract_cells_from_image

      FINAL_CONFIDENCE_THRESHOLD = 0.80


      def print_sudoku_grid(
          grid: np.ndarray,
          conf: np.ndarray | None = None,
          threshold: float = FINAL_CONFIDENCE_THRESHOLD,
      ) -> None:
          """Nicely print a 9×9 Sudoku grid."""
          grid = np.asarray(grid)
          if grid.shape != (GRID_SIZE, GRID_SIZE):
              print("[print_sudoku_grid] invalid shape")
              return

          for r in range(GRID_SIZE):
              if r and r % 3 == 0:
                  print("|-------+-------+-------|")

              line = []
              for c in range(GRID_SIZE):
                  d = grid[r, c]
                  if d == 0:
                      token = "."
                  else:
                      token = str(d)
                      if conf is not None and conf[r, c] < threshold:
                          token = "?"
                  line.append(token)

                  if (c + 1) % 3 == 0 and c != GRID_SIZE - 1:
                      line.append("|")
              print(" ".join(line))
          print()


      def display_results_on_image(
          rectified: np.ndarray, grid: np.ndarray
      ) -> np.ndarray | None:
          """Draw recognised digits onto the rectified grid image."""
          if rectified is None:
              return None

          img = (
              cv2.cvtColor(rectified, cv2.COLOR_GRAY2BGR)
              if rectified.ndim == 2
              else rectified.copy()
          )
          h, w = img.shape[:2]
          cell_h, cell_w = h // GRID_SIZE, w // GRID_SIZE

          for r in range(GRID_SIZE):
              for c in range(GRID_SIZE):
                  d = grid[r, c]
                  if d == 0:
                      continue
                  text = str(d)
                  (tw, th), bl = cv2.getTextSize(text, cv2.FONT_HERSHEY_SIMPLEX, 1, 2)
                  x = c * cell_w + (cell_w - tw) // 2
                  y = r * cell_h + (cell_h + th) // 2
                  cv2.putText(
                      img,
                      text,
                      (x, y),
                      cv2.FONT_HERSHEY_SIMPLEX,
                      1,
                      (0, 255, 0),
                      2,
                      cv2.LINE_AA,
                  )
          return img


      def recognise_sudoku(
          img_path: Path,
          classifier: DigitClassifier,
      ) -> Tuple[np.ndarray, np.ndarray, np.ndarray | None]:
          """Extract cells and run the classifier."""
          print(f"Processing {img_path} ...")
          start = time.time()
          cells, rectified, _ = extract_cells_from_image(img_path)
          if cells is None:
              raise RuntimeError("Extraction failed.")

          pred = np.zeros((GRID_SIZE, GRID_SIZE), int)
          conf = np.zeros_like(pred, float)

          for i, cell in enumerate(cells):
              r, c = divmod(i, GRID_SIZE)
              d, cf = classifier.recognise(cell, confidence_threshold=0.1)
              conf[r, c] = cf
              if d and cf >= FINAL_CONFIDENCE_THRESHOLD:
                  pred[r, c] = d

          print(f"Done in {time.time() - start:.2f}s")
          return pred, conf, rectified


      def main() -> None:
          if len(sys.argv) < 2:
              print("Usage: sudoku_recogniser.py <image>")
              sys.exit(0)

          img_path = Path(sys.argv[1])
          if not img_path.exists():
              print("Image not found.")
              sys.exit(1)

          clf = DigitClassifier(model_path=MODEL_FILENAME)
          if clf.model is None:
              print("Model missing – training required.")
              clf.train()

          grid, conf, rectified = recognise_sudoku(img_path, clf)
          print_sudoku_grid(grid, conf)

          res = display_results_on_image(rectified, grid)
          if res is not None:
              cv2.imshow("Result", res)
              cv2.waitKey(0)
              cv2.destroyAllWindows()


      if __name__ == "__main__":
          main()
      ```

      ---

      ### `sudoku_renderer.py`

      ```python
      # sudoku_renderer.py
      """
      Synthetic Sudoku image generator used for on-the-fly training data creation.
      """
      from __future__ import annotations

      import random
      from pathlib import Path
      from typing import Tuple

      import cv2
      import numpy as np
      import keras

      GRID_SIZE = 9
      BASE_IMAGE_SIZE = 1000
      CELL_SIZE = BASE_IMAGE_SIZE // GRID_SIZE
      MNIST_SIZE = 28


      def _order_points(pts: np.ndarray) -> np.ndarray:
          pts = pts.reshape(4, 2).astype("float32")
          rect = np.zeros((4, 2), dtype="float32")
          s = pts.sum(axis=1)
          rect[0] = pts[np.argmin(s)]
          rect[2] = pts[np.argmax(s)]
          diff = pts[:, 1] - pts[:, 0]
          rect[1] = pts[np.argmin(diff)]
          rect[3] = pts[np.argmax(diff)]
          return rect


      def _load_mnist_digits() -> dict[int, list[np.ndarray]]:
          """Download (once) and prepare MNIST for rendering digits."""
          (x_train, y_train), (x_test, y_test) = keras.datasets.mnist.load_data()
          imgs = np.concatenate([x_train, x_test])
          labels = np.concatenate([y_train, y_test])

          buckets: dict[int, list[np.ndarray]] = {i: [] for i in range(10)}
          for img, lbl in zip(imgs, labels):
              inv = cv2.bitwise_not(img)
              padded = cv2.copyMakeBorder(inv, 4, 4, 4, 4, cv2.BORDER_CONSTANT, value=255)
              buckets[int(lbl)].append(padded)
          return buckets


      class SudokuRenderer:
          """Render a random (optionally given) Sudoku grid to an image."""

          def __init__(self) -> None:
              self.mnist: dict[int, list[np.ndarray]] | None = None

          def _digit_source(self, digit: int) -> Tuple[np.ndarray | None, str]:
              srcs = []
              if self.mnist is None:
                  self.mnist = _load_mnist_digits()
              if self.mnist[digit]:
                  srcs.append("mnist")
              srcs.append("font")
              choice = random.choice(srcs)

              if choice == "mnist":
                  img = random.choice(self.mnist[digit])
                  if img.ndim == 2:
                      img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
                  return img, "mnist"
              return None, "font"

          def render_sudoku(
              self,
              grid_spec: list[list[int | None]] | np.ndarray | None = None,
              *,
              allow_empty: bool = True,
          ):
              """Return (image, gt_grid, warped_corners)."""
              if grid_spec is None:
                  gt = np.zeros((GRID_SIZE, GRID_SIZE), int)
                  for r in range(GRID_SIZE):
                      for c in range(GRID_SIZE):
                          if allow_empty and random.random() < 0.4:
                              continue
                          gt[r, c] = random.randint(1, 9)
              else:
                  gt = np.asarray([[d or 0 for d in row] for row in grid_spec], int)

              bg_color = tuple(random.randint(200, 240) for _ in range(3))
              img = np.full((BASE_IMAGE_SIZE, BASE_IMAGE_SIZE, 3), bg_color, np.uint8)

              for i in range(GRID_SIZE + 1):
                  major = i % 3 == 0
                  thick = random.randint(3 if major else 1, 5 if major else 3)
                  cv2.line(img, (0, i * CELL_SIZE), (BASE_IMAGE_SIZE, i * CELL_SIZE), (0, 0, 0), thick)
                  cv2.line(img, (i * CELL_SIZE, 0), (i * CELL_SIZE, BASE_IMAGE_SIZE), (0, 0, 0), thick)

              for r in range(GRID_SIZE):
                  for c in range(GRID_SIZE):
                      d = gt[r, c]
                      if d == 0:
                          continue

                      src_img, src_type = self._digit_source(d)
                      scale = random.uniform(0.5, 0.8)
                      tgt_h = tgt_w = int(CELL_SIZE * scale)
                      center_x = c * CELL_SIZE + CELL_SIZE // 2
                      center_y = r * CELL_SIZE + CELL_SIZE // 2
                      offset_x = int(random.uniform(-0.1, 0.1) * CELL_SIZE)
                      offset_y = int(random.uniform(-0.1, 0.1) * CELL_SIZE)
                      cx, cy = center_x + offset_x, center_y + offset_y

                      if src_type == "mnist":
                          rot = random.uniform(-10, 10)
                          M = cv2.getRotationMatrix2D((tgt_w / 2, tgt_h / 2), rot, 1)
                          digit = cv2.resize(src_img, (tgt_w, tgt_h))
                          digit = cv2.warpAffine(
                              digit,
                              M,
                              (tgt_w, tgt_h),
                              borderMode=cv2.BORDER_CONSTANT,
                              borderValue=(255, 255, 255),
                          )
                          mask = cv2.cvtColor(digit, cv2.COLOR_BGR2GRAY)
                          _, mask = cv2.threshold(mask, 250, 255, cv2.THRESH_BINARY_INV)

                          x0 = max(0, cx - tgt_w // 2)
                          y0 = max(0, cy - tgt_h // 2)
                          roi = img[y0 : y0 + tgt_h, x0 : x0 + tgt_w]
                          mask_inv = cv2.bitwise_not(mask[: roi.shape[0], : roi.shape[1]])
                          bg = cv2.bitwise_and(roi, roi, mask=mask_inv)
                          fg = cv2.bitwise_and(digit, digit, mask=mask[: roi.shape[0], : roi.shape[1]])
                          img[y0 : y0 + roi.shape[0], x0 : x0 + roi.shape[1]] = cv2.add(bg, fg)
                      else:
                          font = cv2.FONT_HERSHEY_SIMPLEX
                          thickness = random.randint(1, 3)
                          font_scale = cv2.getFontScaleFromHeight(font, tgt_h, thickness) * 0.8
                          tw, th = cv2.getTextSize(str(d), font, font_scale, thickness)[0]
                          x = cx - tw // 2
                          y = cy + th // 2
                          cv2.putText(
                              img,
                              str(d),
                              (x, y),
                              font,
                              font_scale,
                              (0, 0, 0),
                              thickness,
                              cv2.LINE_AA,
                          )

              noise = np.random.normal(0, random.uniform(5, 20), img.shape).astype(np.float32)
              img = np.clip(img.astype(np.float32) + noise, 0, 255).astype(np.uint8)

              h, w = img.shape[:2]
              orig = np.array([[0, 0], [w - 1, 0], [w - 1, h - 1], [0, h - 1]], "float32")
              shift = random.uniform(0.05, 0.2)
              max_x, max_y = w * shift, h * shift
              dst = np.array(
                  [
                      [random.uniform(0, max_x), random.uniform(0, max_y)],
                      [w - 1 - random.uniform(0, max_x), random.uniform(0, max_y)],
                      [
                          w - 1 - random.uniform(-max_x * 0.2, max_x),
                          h - 1 - random.uniform(0, max_y * 0.5),
                      ],
                      [random.uniform(-max_x * 0.2, max_x), h - 1 - random.uniform(0, max_y * 0.5)],
                  ],
                  "float32",
              )
              M = cv2.getPerspectiveTransform(orig, dst)
              out_w, out_h = int(np.ceil(dst[:, 0].max())), int(np.ceil(dst[:, 1].max()))
              warped = cv2.warpPerspective(img, M, (out_w, out_h), borderMode=cv2.BORDER_REPLICATE)
              return warped, gt, dst


      def generate_and_save_test_example(
          prefix: str = "epoch_test_sudoku", *, force: bool = False
      ):
          img_path = Path(f"{prefix}.png")
          gt_path = Path(f"{prefix}_gt.npy")

          if not force and img_path.exists() and gt_path.exists():
              return str(img_path), np.load(gt_path)

          renderer = SudokuRenderer()
          img, gt, _ = renderer.render_sudoku(
              grid_spec=[
                  [None, None, 3, None, None, 6, None, 8, None],
                  [8, None, 1, None, 3, None, 5, None, 4],
                  [None, 4, None, 8, None, 7, None, 1, None],
                  [1, None, None, 4, None, 5, None, None, 9],
                  [None, 7, None, None, 2, None, None, 4, None],
                  [5, None, None, 7, None, 1, None, None, 3],
                  [None, 8, None, 5, None, 3, None, 9, None],
                  [7, None, 4, None, 9, None, 1, None, 8],
                  [None, 1, None, 6, None, None, 4, None, None],
              ]
          )
          cv2.imwrite(str(img_path), img)
          np.save(gt_path, gt)
          return str(img_path), gt
      ```

      ---

      All files are now clean, consistent, and ready for further development or review.
    metadata:
  - user: |
      --- Phase 1: Processing explicit file paths in fences ---
      Remaining unassigned blocks: 4, Available files: 4
      --- Phase 2: Checking preceding lines for hints ---
      Remaining unassigned blocks: 4, Available files: 4
      --- Phase 3: Checking first lines inside blocks for hints ---
      Assigned block to digit_classifier.py based on first line hint: '# digit_classifier.py'.
      Assigned block to digit_extractor.py based on first line hint: '# digit_extractor.py'.
      Assigned block to sudoku_recogniser.py based on first line hint: '# sudoku_recogniser.py'.
      Assigned block to sudoku_renderer.py based on first line hint: '# sudoku_renderer.py'.
      Remaining unassigned blocks: 0, Available files: 0
      --- Phase 6: Applying changes to assigned files ---
      Successfully updated file: digit_classifier.py
      Successfully updated file: digit_extractor.py
      Successfully updated file: sudoku_recogniser.py
      Successfully updated file: sudoku_renderer.py
    metadata:
...
