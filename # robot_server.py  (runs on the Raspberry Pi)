import socket
import sys
import signal
from time import sleep
from gpiozero import OutputDevice

# ─── GPIO definitions ──────────────────────────────────────────────────────────
LEFT_PINS  = (5, 6, 16, 20)
RIGHT_PINS = (14, 15, 23, 24)

step_sequence = [
    [1, 0, 0, 0],
    [1, 1, 0, 0],
    [0, 1, 0, 0],
    [0, 1, 1, 0],
    [0, 0, 1, 0],
    [0, 0, 1, 1],
    [0, 0, 0, 1],
    [1, 0, 0, 1],
]

class Stepper:
    def __init__(self, pins):
        self.pins = [OutputDevice(p) for p in pins]
        self.pos  = 0  # index into step_sequence

    def deenergise(self):
        for p in self.pins:
            p.off()

    def _set_step(self, idx):
        pattern = step_sequence[idx]
        for pin, val in zip(self.pins, pattern):
            pin.value = val

    def step(self, direction=1, delay=0.001):
        self.pos = (self.pos + direction) % len(step_sequence)
        self._set_step(self.pos)
        sleep(delay)

# ─── Movement helpers ─────────────────────────────────────────────────────────
left  = Stepper(LEFT_PINS)
right = Stepper(RIGHT_PINS)

def forward(steps=8):
    for _ in range(steps):
        left.step(+1)
        right.step(+1)

def backward(steps=8):
    for _ in range(steps):
        left.step(-1)
        right.step(-1)

def left_turn(steps=8):
    for _ in range(steps):
        left.step(-1)
        right.step(+1)

def right_turn(steps=8):
    for _ in range(steps):
        left.step(+1)
        right.step(-1)

COMMANDS = {
    "FORWARD":  forward,
    "BACKWARD": backward,
    "LEFT":     left_turn,
    "RIGHT":    right_turn,
    "STOP":     lambda: None,
}

# ─── Networking & main loop ───────────────────────────────────────────────────
HOST = ""       # listen on all interfaces
PORT = 5005
BUFFER = 1024

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind((HOST, PORT))
sock.settimeout(0.5)  # allows us to react to Ctrl-C

def clean_exit(*_):
    print("Shutting down…")
    left.deenergise()
    right.deenergise()
    sock.close()
    sys.exit(0)

signal.signal(signal.SIGINT,  clean_exit)
signal.signal(signal.SIGTERM, clean_exit)

print(f"Robot server ready on UDP port {PORT}")

try:
    while True:
        try:
            data, _ = sock.recvfrom(BUFFER)
        except socket.timeout:
            continue
        cmd = data.decode().strip().upper()
        if cmd == "QUIT":
            clean_exit()
        action = COMMANDS.get(cmd)
        if action:
            action()
except KeyboardInterrupt:
    clean_exit()
